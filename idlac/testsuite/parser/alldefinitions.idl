/********************************************************
       This file is meant to try every definition
    of the idl langage in order to test the idl parser
*********************************************************/

/************************/
/* First, try each rule */
/************************/

// Rule 0 : preprocessor
#include "testparser_include.idl"
#line 500
#line 14
//#pragma toto

// Rule 1
const short const1 = 4;

// Rule 2
typedef long long1;
const short const2 = 2;
exception exception1 {};
interface interface1 {};
module module3 {const short const1 = 3;};
valuetype valuetype1 {};

// Rule 3
module module4 {const short const1 = 3;};
module module5 {const short const1 = 3;
		const short const2 = 3;};

// Rule 4
interface interface2;
interface interface2 {};

// Rule 5
interface interface3 {long echo_long (in long l);};

// Rule 6
interface interface4;
abstract interface interface5;
interface interface4 {};
abstract interface interface5 {};

// Rule 7
interface interface6 {};
abstract interface interface7 {};
interface interface8 : interface6 {};
abstract interface interface9 : interface7 {};

// Rule 8
interface interface10 {};
interface interface11 {long echo_long (in long l);};

// Rule 9
interface interface12 {
   typedef long long1;
   const short const2 = 2;
   exception exception1 {};
   attribute long attr1;
   long echo_long (in long l);
};

// Rule 10
interface interface13 : interface6 {};
interface interface14 : interface6, interface12 {};
interface interface15 : interface6, interface12, interface13 {};

// Rule 11
module module6 {
  interface inter {};
};
//interface interface16 : ::module6::inter {};

// Rule 12
module module7 {
   typedef long type1;
};
typedef long type1;
typedef type1 type2;
//typedef module7::type1 type4;
//typedef ::module7::type1 type3;

// Rule 13
valuetype value1{};
abstract valuetype value2{};
valuetype value3 long;
valuetype value4;
valuetype value4{};

// Rule 14
valuetype value5;
valuetype value5{};
abstract valuetype value6;
abstract valuetype value6{};

// Rule 15
valuetype value7 long;

// Rule 16
abstract valuetype value8  {};
abstract valuetype value9  {const short a = 2;};
abstract valuetype value10  {const short a = 2;const short b = 2;};
abstract valuetype value11 : value6 {};
abstract valuetype value12 : value6 {const short a = 2;};
abstract valuetype value13 : value6 {const short a = 2;const short b = 2;};

// Rule 17
valuetype value14 {};
valuetype value15 {const short a = 2;};
valuetype value16 {const short a = 2;const short b = 2;};

// Rule 18
valuetype value17 {};
custom valuetype value18 {};
valuetype value19 : value17 {};
custom valuetype value20 : value19 {};

// Rule 19
valuetype value21 : value17 {};
valuetype value22 : value17, value8 {};
valuetype value23 : value17, value8, value9 {};
valuetype value24 : truncatable value17 {};
valuetype value25 : truncatable value17, value8 {};
valuetype value26 : truncatable value17, value8, value9 {};
valuetype value27 supports interface6 {};
valuetype value28 supports interface6, interface5 {};
valuetype value29 supports interface6, interface5, interface7 {};
valuetype value30 : value17 supports interface6 {};
valuetype value31 : value17 supports interface6, interface5 {};
valuetype value32 : value17 supports interface6, interface5, interface7 {};
valuetype value33 : truncatable value17 supports interface6 {};
valuetype value34 : truncatable value17 supports interface6, interface5 {};
valuetype value35 : truncatable value17 supports interface6, interface5, interface7 {};

// Rule 20
module module8 {
   valuetype value {};
};
//valuetype value36 : ::module8::value {};

// Rule 21
valuetype value37 {
   const short a = 2;
   public long l;
   factory f();
};

// Rule 22
valuetype value38 {
   public long l;
   private short s;
};

// Rule 23
valuetype value39 {
   factory f();
   factory g(in short s);
};

// Rule 24
valuetype value40 {
   factory f(in short s);
   factory g(in short s, in long l);
};

// Rule 25
valuetype value41 {
   factory f(in short s);
};

// Rule 26
valuetype value42 {
   factory f(in short s);
};

// Rule 27
const short const3 = 3;

// Rule 28

const short const4 = 3;
const char const5 = 'd';
const wchar const6 = L'd';
const boolean const7 = TRUE;
const float const8 = 3.14;
const string const9 = "string";
const wstring const10 = L"wstring";
const fixed<5,3> const11 = 3.141d;
typedef long type4;
const type4 const12 = 5;
typedef type4 type5;
const type5 const13 = 5;
const octet const14 = 2;

// Rule 29
const short const15 = 5;

// Rule 30
//const short const16 = 3 | -28;
//const short const17 = 3 | -28 | 12;

// Rule 31
//const short const18 = 3 ^ -28;
//const short const19 = 3 ^ -28 ^ 12;

// Rule 32
//const short const20 = 3 & -28;
//const short const21 = 3 & -28 & 12;

// Rule 33
//const short const22 = 345 << 8;
//const short const23 = 345 << 2 << 6;
//const short const24 = 345 >> 8;
//const short const25 = 345 >> 2 >> 6;

// Rule 34
//const short const23 = 345 + 8;
//const short const24 = 345 + 2 + 6;
//const short const25 = 345 - 8;
//const short const26 = 345 - 2 - 6;
//const short const27 = 345 - 2 + 6;
//const short const28 = 345 + 2 - 6;

// Rule 35
//const short const29 = 345 * 8;
//const short const30 = 345 * 2 * 4;
//const short const31 = 345 / 8;
//const short const32 = 345 / 2 / 4;
//const short const33 = 345 % 8;
//const short const34 = 345 % 4 % 2;
//const short const35 = 345 * 4 / 2;
//const short const36 = 345 / 4 * 2;
//const short const37 = 345 * 4 % 5;
//const short const38 = 345 % 4 * 5;
//const short const39 = 345 / 4 % 5;
//const short const40 = 345 % 4 / 5;

// Rule 36
//const short const41 = - 17;

// Rule 37
//const short const42 = - 17;
//const short const43 = + 17;
//const short const44 = ~ 17;

// Rule 38
module module9 {
   const short c = 2;
};
//const short const45 = ::module9::c;
//const short const46 = module9::c;
//const short const47 = 18;
//const short const48 = ( 1 | 3 ^ 20 >> 1 & 7 << 2 + -9 - +11 * 13 / 15 % ~17);

// Rule 39
const short const49 = 0;
const short const50 = 12;
const short const51 = 014;
const short const52 = 0xC;
const string const53 = "a string";
const string const54 = "a more"" complicated"" one";
const string const55 = "two" "strings";
const string const56 = "very """ """complicated""";
const string const57 = "with a \\ inside";
const string const58 = "with a \""" inside";
const string const59 = "with an octal char : \123";
const string const60 = "with an octal char : \12345";
const string const61 = "with an octal char : \03";
const string const62 = "with an hexa char : \xab";
const string const63 = "with an hexa char : \xabcd";
const string const64 = "with a unicode char : \uabcd";
const string const65 = "with a unicode char : \uabcdef";
const string const66 = " a
                   multiline 
                             string";
const wstring const67 = L"a string";
const wstring const68 = L"a more"" complicated"" one";
const wstring const69 = L"two" "strings";
const wstring const70 = L"very """ """complicated""";
const char const71 = 'r';
const char const72 = '\n';
const char const73 = '\'';
const char const74 = '\\';
const char const75 = '\1';
const char const76 = '\12';
const char const77 = '\123';
const char const78 = '\xa';
const char const79 = '\xab';
const char const80 = '\ua';
const char const81 = '\uab';
const char const82 = '\uabc';
const char const83 = '\uabcd';
const wchar const84 = L'r';
const wchar const85 = L'\n';
const wchar const86 = L'\'';
const wchar const87 = L'\\';
const wchar const88 = L'\1';
const wchar const89 = L'\12';
const wchar const90 = L'\123';
const wchar const91 = L'\xa';
const wchar const92 = L'\xab';
const wchar const93 = L'\ua';
const wchar const94 = L'\uab';
const wchar const95 = L'\uabc';
const wchar const96 = L'\uabcd';












const float const100 = 1.45;
const float const101 = 0.2;
const float const102 = .3;
const float const103 = 3.;
const float const104 = 5e3;
const float const105 = 3E4;
const float const106 = .3e4;
const float const107 = 2d;
const float const108 = 5D;
const float const109 = 3.4d;
const float const110 = .5d; 
const boolean const111 = TRUE;
const boolean const112 = FALSE;



// Rule 40
// Rule 41
// Rule 42
// Rule 43
// Rule 44
// Rule 45
// Rule 46
// Rule 47
// Rule 48
// Rule 49
// Rule 50
// Rule 51
// Rule 52
// Rule 53
// Rule 54
// Rule 55
// Rule 56
// Rule 57
// Rule 58
// Rule 59
// Rule 60
// Rule 61
// Rule 62
// Rule 63
// Rule 64
// Rule 65
// Rule 66
// Rule 67
// Rule 68
// Rule 69
// Rule 70
// Rule 71
// Rule 72
// Rule 73
// Rule 74
// Rule 75
// Rule 76
// Rule 77
// Rule 78
// Rule 79
// Rule 80
// Rule 81
// Rule 82
// Rule 83
// Rule 84
// Rule 85
// Rule 86
// Rule 87
// Rule 88
// Rule 89
// Rule 90
// Rule 91
// Rule 92
// Rule 93
// Rule 94
// Rule 95
// Rule 96
// Rule 97
// Rule 98


/*******************************/
/* Now, try each miscellaneous */
/*  point of the Idl langage   */
/*******************************/


