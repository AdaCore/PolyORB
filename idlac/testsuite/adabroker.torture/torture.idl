// AdaBroker torture test.
// This IDL file tests a lot of parser, expander and
// code generator features.
// $Id$

module MyModule {

  // typedef string B_ARRAY[123];

  // Parser bug: the conflict with member b
  // of struct MyStruct below triggers an exception,
  // instead of a renaming of the structure's array
  // type.

  struct MyStruct {
    unsigned long MyInt;
    boolean member3[4][8];
    long a, b[2], c, d, e[4];
  };
  enum Color { Red, Green, Blue, Grey };
  typedef sequence<Color> longSpectrum;

  typedef sequence<sequence<Color> > bidimSpectrum;
  typedef sequence<sequence<long,9>> bidimSparseArray;

  typedef Color Hue, Tint, Paint;
  typedef Color spectrum[7];
  typedef Color foo;

  // Enum E2 must be moved out of the switch type
  // spec by expansion.
  union U switch (enum E2 { XX2, XY2 }) {
  case XX2:
    long hair;
  case XY2:
    long beard;
  };

  //  Check that scoped-names that denote enumerators
  //  are parsed correctly.
  union Example switch (Color) {
    case Red: case Green: long Counter;
    case Blue: boolean Flags[4][8];
    default: long Unknown;
  };

  typedef struct Complex {
    double Re;
    double Im;
  } complexNumber;

  typedef string<2> saltString;

  typedef unsigned long uid_t;
  typedef unsigned long gid_t;

  struct passwd {
    string<8>	pw_name;	/* user name */
    string<13>	pw_passwd;	/* user password */
    uid_t	pw_uid;		/* user id */
    gid_t	pw_gid;		/* group id */
    wstring	pw_gecos;	/* real name */
    string	pw_dir;		/* home directory */
    string	pw_shell;	/* shell program */
  };

  union U3 switch (boolean) {
    case TRUE: long foo;
    case FALSE: string bar;
  };

  interface MyInterface;

  typedef sequence<unsigned long> longSeq;

  interface MyInterface {
    string echoString (in string arg);
    Color echoColor (in Color arg);
    MyInterface echoRef (in MyInterface arg);
    longSeq echoLongSeq (in longSeq arg);
  };
  #pragma ID MyInterface "IDL:toto/titi/tata/tutu:1.0"
  
  exception MyException {
    unsigned long Einfo;
  };

  interface IfB : MyInterface {
    long echoLong (in long Arg);
    void bindWith (in MyInterface otherInterface);
    void testException (in long Arg)
      raises (MyModule::MyException);
    readonly attribute unsigned long inBytes, outBytes;
    attribute Color currentColorSetting;
  };
  interface smallIf {
    void smallOp (in long arg);
  };
  interface IfC : smallIf, IfB {
    void foo ();
  };
  interface IfD : IfC, MyInterface {
    void bar ();
  };
  typedef Complex Complex2;
  typedef complexNumber complexNumber2;
#if 0
  typedef MyInterface MyReference;
  // Must resolve to a /forward/ reference.

  typedef MyReference anObjectReference;
  typedef MyReference referencePack[5];
  typedef MyInterface bunchOfObjects[2][4];
#endif

  interface Chicken;
  interface Egg;
  interface Egg {
    Chicken hatch ();
  };
  interface Chicken {
    Egg lay ();
  };

  // A test-case from the adabroker mailing list.

  module Ss_Reu_Time_Utilities {

    typedef long Time_Stamp_Type;
    typedef long Relative_Time_Stamp_Type;

    enum Time_Format_Type { H_Hour, On_Call, Absolute };

    union Uniform_Time_Type switch ( Time_Format_Type ) {
      case H_Hour:
      case On_Call:
         Relative_Time_Stamp_Type       Relative_Time_Stamp;
      case Absolute:
         Time_Stamp_Type                Time_Stamp;
    };
  };

#if 0
  //  This occurs after a module {}:
  //  Expansion won't work if it does not
  //  Pop_Scope correctly.

  typedef struct coords {
    double x;
    double y;
  } point;

  union U2 switch (long) {
    case 0: wstring<99> name;
    case 1: Complex c;
  };
#endif
};

typedef MyModule::complexNumber2 rootCplx;
typedef ::MyModule::Complex rootCplx1;
typedef MyModule::MyInterface rootRef;
typedef long rootLong;
