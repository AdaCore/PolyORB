TODO for PolyORB
---------------

$Id$

Items still requiring attention
-------------------------------

* Clarify the uniform interface of representations:
  either create a PolyORB.Representations.CDR.CDR_Representation
  type (derived from P.R.Representation) or remove P.R.Representation
  altogether.

* Fix memory leaks (to be checked with Debug_Pools disabled!)

* Extend Transport framework with a new abstract class
  Transport_Access_Point_Name with a bind() primitive operation
  that returns a Transport_Endpoint.

* Factor out common code between different versions of
  PolyORB.Binding_Data.*. Incorporate Transport_Access_Point_Name
  usage as a Binding_Object_Fragment_Factory (extension of the
  notion of Filter_Factory to fragments of binding objects that
  are not filter). Think Netgraph.

* Exception support: separate personality-specific (CORBA)
  code from generic code. Check proper implementation of
  DSA exception. Document mapping between both models.

* Ada 95 DSA personality:
  -> Asynchronous
  -> RACW 'Read/'Write
  -> From_Any and To_Any for tagged records and variant records.
   
* Bind-time configuration tool (to help the user generate a configuration
  package suited to his needs.)

* Run-time configuration of loaded functionality (using Adaplugins ?)

* See whether Buffers.Set_Initial_Position can be made private
  or moved to unit body.

* Support logging to syslog (also for Java ?)

* PolyORB.Buffers: remove mentions of CDR.
* PolyORB.Buffers: remove mention of sockets.
* PolyORB.Buffers: Zero-copy buffers.

* Configuration of memory allocation:
  -> real-time allocator?
  -> usage of Storage_Pools?
  -> static allocation?
  -> smart resource management (garbage collection, system audit...)?

  See Allocator abstract class in Quarterware.

* HTTP protocol (to be used with Minimal_Servant to compose a
  web server).

* CSTA protocol (for telephony applications.)

* Alternative implementations of transport endpoints:

  -> A mechanism for use of non-connected message passing
     protocols (eg UDP, email).
   
  -> A mechanism for optional implementation of reliable
     message delivery over a non-reliable message delivery
     protocol (eg UDP with ack/retransmission)
     
  -> A mechanism for message exchange not based on sockets
     (eg SysV IPC, serial lines).

* Architecture documentation.

Items processed
---------------

* Data reception: when the protocol knows how much data will
  arrive, preallocate so that unmarshalling is guaranteed
  to be presented with contiguous data.
  When it does not, Receive_Buffer should call Receive_Socket
  with Length no greater than the available space in the
  chunk, and advance the current position by the exact
  size of the received data (2770).

* Rework PolyORB.ORB event handling:
  The event handling loop must occur within the critical
  section (because it must mask certain sockets).
  Jobs should be created for each event, which will be
  actually processed by ORB tasks (2770).

* A filter to gather a message of a given size from lower
  layers before signalling to upper layers (as did the old
  Channel type) (2830).

* An abstraction of transport endpoints (2871).

* An object adapter.

* Use of the Ravenscar profile.

* Profile type registration system (for References.IOR).
  For a profile to be used when creating and parsing IORs,
  its tag must be registered.

* Move CORBA.POA to PolyORB.<something> (3329).

* Make PolyORB.References.Ref a Smart_Pointers.Entity
  so the list of profiles can be free'd when not used
  anymore.

* When a connection is closed, release all associated resources.

* Make compliant PortableServer tree for CORBA personality.

* Correct handling of arg modes in SOAP (in/inout/out).
  The SOAP engine sees incoming argument and marks them as IN.
  If the object expects some args to be inout or out, make
  sure that before calling the object, the parameters are present
  and marked with proper modes. Then, the SOAP engine knows to
  send out any INOUT or OUT argument with the reply.

* Make idlac compilable under -gnaty.
