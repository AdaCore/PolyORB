TODO for Droopi
---------------

$Id$

Items still requiring attention
-------------------------------

* Support logging to syslog (also for Java ?)
* Unified runtime configuration file (modifications to Droopi.Log).

* When a connection is closed, release all associated resources.

* Droopi.Buffers: remove mentions of CDR.
* Droopi.Buffers: remove mention of sockets.

* Different tasking configurations
  -> A single-task client configuration.
  -> A multi-tasking server configuration.
  -> A multi-tasking client configuration.

* Configuration of memory allocation:
  -> usage of Storage_Pools?
  -> static allocation?
  -> real-time allocator?
  -> smart resource management (garbage collection, system audit...)?

  See Allocator abstract class in Quarterware.

* Alternative implementations of transport endpoints:

  -> A mechanism for use of non-connected message passing
     protocols (eg UDP).
   
  -> A mechanism for optional implementation of reliable
     message delivery over a non-reliable message delivery
     protocol (eg UDP with ack/retransmission)
     
  -> A mechanism for message exchange not based on sockets
     (eg SysV IPC).
     A provision for polling multiple sources of asynchronous
     events.

* Architecture documentation.

Items processed
---------------

* Data reception: when the protocol knows how much data will
  arrive, preallocate so that unmarshalling is guaranteed
  to be presented with contiguous data.
  When it does not, Receive_Buffer should call Receive_Socket
  with Length no greater than the available space in the
  chunk, and advance the current position by the exact
  size of the received data (2770).

* Rework Droopi.ORB event handling:
  The event handling loop must occur within the critical
  section (because it must mask certain sockets).
  Jobs should be created for each event, which will be
  actually processed by ORB tasks (2770).

* A filter to gather a message of a given size from lower
  layers before signalling to upper layers (as did the old
  Channel type) (2830).

* An abstraction of transport endpoints (2871).

* An object adapter.

* Use of the Ravenscar profile.
