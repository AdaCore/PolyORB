#! /usr/bin/env python

# Generate a perfect hash function and Ada body from a specially
# formatted Ada spec that defines an enumerated type and a string
# list.

# $Id$

import sys, os, re, getopt, string

def usage():
  print "Usage: $0 [-c] <file.ads>"
  print "  -c: produce a case-sensitive matcher"
  sys.exit (1)

case_sensitive = 0

optlist,args = getopt.getopt (sys.argv[1:],'S:')
for opt,optarg in optlist:
  if opt == '-c':
    case_sensitive = 1
    
if len (args) != 1:
  usage ()

ads = args [0]
prefix = os.path.basename (ads)[:-4]
adb=prefix + ".adb"
perf=prefix + ".perf"
os.unlink (perf)
os.unlink (adb)
hperf = open (perf, "w")
hadb = open (adb, "w")
cfile=prefix + "_GPERF.c"

unit = prefix
matchfun = string.replace (unit, "-", "__") + "__IN_WORD_SET"

i = 0
st = 0
gpa = ""
values = []
hperf.write ("%{\nenum kwids {\n")
for ll in open (ads).readlines():
  l = string.rstrip (ll)
  m = re.match ("^package ([^ ]*) is", l)
  if m:
    pkg = m.group (1)
    continue

  m = re.match ("\s*type (\w*) is", l)
  if m:
    ent = m.group (1)
    continue

  m = re.match ('.*<GPERF ARGS="([^"]*)"\/>', l)
  if st == 0 and m:
    gpa = m.group (1)
    continue

  if st == 0 and re.match (".*<ENUM>", l):
    st = 1
    continue

  if st == 1 and re.match (".*</ENUM>", l):
    st = 0
    hperf.write ("};\n%}\n")
  
    hperf.write ("struct kwinfo { char *name; enum kwids id; };\n")
    hperf.write ("%%\n")

    for v in values:
      if case_sensitive:
        hperf.write (v [1] + ", " + v[0] + "\n")
      else:
        hperf.write (string.lower (v[1]) + ", " + v[0] + "\n")
    continue

  if st == 1:
    m = re.match ('[ 	]*([^ 	,]*),?[ 	]*--  >> "([^"]*)"', l)
    if m:
      hperf.write ("  " + m.group (1) + ", /* \"" + m.group (2) + "\" */\n")
      values.append (m.groups ())
      i = i + 1
    else:
      m = re.match ('[ 	]*([^ 	,-]+)([, 	-].*)?$', l)
      if m:
        hperf.write ("  " + m.group (1) + ", /* no-match case */\n")
        unk=m.group (1)
      
hperf.close ()
os.system ("gperf -N %s -t %s %s > %s" % (matchfun, gpa, perf, cfile))

if unk != "":
  unk_handler="return " + unk + ";"
else:
  unk_handler="raise Constraint_Error;"

if case_sensitive:
  initval = "S"
else:
  hadb.write ("with Ada.Characters.Handling; use Ada.Characters.Handling;\n")
  initval = "To_Lower (S)"
  
hadb.write ("""with Interfaces.C; use Interfaces.C;
with Interfaces.C.Strings; use Interfaces.C.Strings;

package body %s is

   type Keyword_Info is record
      Name : Interfaces.C.Strings.chars_ptr;
      Id   : %s;
   end record;
   type Keyword_Info_Access is access all Keyword_Info;
   pragma Convention (C, Keyword_Info);
   pragma Convention (C, Keyword_Info_Access);

   function C_In_Word_Set
     (S : chars_ptr; Len : int)
     return Keyword_Info_Access;
   pragma Import (C, C_In_Word_Set, "%s");

   function In_Word_Set (S : String) return %s
   is
      Chars : aliased char_array := To_C (%s);
      Info : constant Keyword_Info_Access
        := C_In_Word_Set
          (To_Chars_Ptr (Chars'Unchecked_Access), S'Length);
   begin
      if Info /= null then
         return Info.Id;
      end if;
      %s
   end In_Word_Set;

   function To_String (Id : %s) return String is
   begin
      case Id is
""" % (pkg, ent, matchfun, ent, initval, unk_handler, ent))

for v in values:
  hadb.write ("         when " + v[0] + " =>\n")
  hadb.write ('            return "' + v[1] + '";\n')
  
  
if unk != "":
  hadb.write ("         when others =>\n")
  hadb.write ("            raise Constraint_Error;\n")

hadb.write ("""      end case;
   end To_String;

end %s;\n"""% (pkg))
hadb.close ()
