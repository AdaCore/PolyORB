\input texinfo @c -*-texinfo-*-
@setfilename glade_ug.info
@settitle GLADE User's Guide
@setchapternewpage odd
@syncodeindex fn cp

@titlepage

@title GLADE User's Guide
@subtitle GLADE, GNAT Library for Ada Distributed Environment
@subtitle Version 2.01 (DRAFT)
@subtitle December 16, 1997
@author Laurent Pautet, Samuel Tardieu

@page
@vskip 0pt plus 1filll

@copyright{} Copyright 1997-1997, Free Soft Foundation.

GLADE is free software; you can redistribute it and/or modify it under
terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version. GNAT is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANT
ABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
License for more details.  You should have received a copy of the GNU
General Public License along with GNAT; see file COPYING. If not, write
to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

@end titlepage

@ifinfo
@node Top, Tutorial on the Distributed Systems Annex, (dir), (dir)
@top GLADE User's Guide

GLADE is the GNAT implementation of Distributed Systems Annex.

@menu
* Tutorial on the Distributed Systems Annex::  
* Getting Started With GLADE::  
* Index::                       
@end menu

@end ifinfo

@node Tutorial on the Distributed Systems Annex, Getting Started With GLADE, Top, Top
@chapter Tutorial on the Distributed Systems Annex

@menu
* Introduction To Distributed Systems::  
* The Distributed System Annex::  
* Architecture of A DSA Application::  
* Presentation Of Categorization Pragmas::  
* Most Features in One Example::  
* Non-Distributed versus Distributed Applications::  
@end menu

@node Introduction To Distributed Systems, The Distributed System Annex, Tutorial on the Distributed Systems Annex, Tutorial on the Distributed Systems Annex
@section Introduction To Distributed Systems

@menu
* Using OS Network Services::   
* Using A Middleware Environment::  
* Using A Distributed Language::  
@end menu

A distributed system architecture comprises a network of computers and the
software components that execute on the computers. Such architectures are
commonly used to improve the performance, reliability, and reusability of
complex applications. Typically, when there is no shared address space
available to remotely-located components, components must communicate using
some form of message-passing abstraction.

@node Using OS Network Services, Using A Middleware Environment, Introduction To Distributed Systems, Introduction To Distributed Systems
@subsection Using OS Network Services

There are several programming techniques for developing distributed
applications. These applications have traditionally been developed using
network programming interfaces such as sockets. Programmers explicitly
have to perform calls to operating system services, a task that can be
tedious and error-prone. This includes initializing socket connection
and determining peer location, marshaling and unmarshaling data
structures, sending and receiving messages, debugging and testing
several programs at the same time and porting on several platforms to
hide subtle differences between various network interfaces.

Of course, this code can be encapsulated in wrappers to reduce its
complexity but it is clear that most of it can be automatically
generated. Message passing diverts developer's attention from the
application domain. The query and reply scenario is a classical scheme
in distributed applications; using message passing in such a situation
could be compared to using a ``goto'' mechanism in a non-distributed
application.  This is known to be a significant problem in the domain of
modern programming languages. A more robust design would be to use a
structured approach based on procedure call.

In some respects, this network programming issue can be compared to the
multi-threading programming issue. An user can decide to split his code
in several pieces and to multiplex the thread executions himself using a
table-driven model. The scheduling code would be embedded into the user
code. This solution is error-prone and fragile in regard to any future
modification.

@node Using A Middleware Environment, Using A Distributed Language, Using OS Network Services, Introduction To Distributed Systems
@subsection Using A Middleware Environment

A middleware environment is intended to provide high level abstractions
in order to easily develop user applications.  Environments like CORBA
or Distributed Computing Environment (DCE) propose an approach to
develop client/server applications using the Remote Procedure Call model
(RPC). The RPC model is inspired from the query and reply
scheme. Compared to a regular procedure call, arguments are pushed into
a stream along with some data pointing out which remote procedure is to
be used and the stream is transmitted over the network to the
server. The server decodes the stream, does the regular subprogram call,
then put the output parameters into another stream along with the
exception (if any) raised by the subprogram and sends this stream back
to the caller. The caller decodes the stream and raises the exception if
needed.

CORBA provides the same enhancements to the remote procedure model that
object languages provide to classical procedural languages.  This also
includes encapsulation, inheritance, type checking, and
exceptions. These features are offered through an Interface Definition
Language (IDL).

The middleware communication framework provides all the machinery to
perform, somewhat transparently, remote procedure calls or remote object
method invocations. For instance, each CORBA interface communicates
through an Object Request Broker (ORB). A communication subsystem such
as an ORB is intended to allow applications to use objects without being
aware of their underlying message passing implementation. But the user
may also require a large number of complex services to develop the
distributed application. Some of them are definitively needed like a
location service that allows clients to reference remote services via
higher level names instead of a traditional scheme for addressing remote
services involving Internet host addresses and communication port
number. Other services provide domain independent interfaces that are
frequently used by distributed applications like naming services.

If we get back to the multi-thread programming comparison, the
middleware solution is close to what a POSIX library or a language like
Esterel would propose to develop a concurrent application. A middleware
framework like DCE is close to a POSIX library in terms of abstraction
levels. Functionalities are very low-level and very complex. CORBA is
closer to Esterel in terms of development process.  The control part of
the application can be specified in a description language. The
developer then has to fill in automatically generated source code (stub
and skeletons) to call the computation part of the application. The
distribution is a pre-compilation process and the distributed boundaries
are always explicit. Using CORBA, the distributed part is written in IDL
and the core of the application is written in a host language.

@node Using A Distributed Language,  , Using A Middleware Environment, Introduction To Distributed Systems
@subsection Using A Distributed Language

Rather than defining a new language like an IDL, an alternative idea is
to extend a programming language in order to provide distributed
features. The distributed object paradigm provides a more
object-oriented approach to programming distributed systems. The notion
of a distributed object is an extension to the abstract data type that
permits the services provided in the type interface to be called
independently of where the actual service is executed. When combined
with object-oriented features such as inheritance and polymorphism,
distributed objects promote a more dynamic and structured computational
environment for distributed applications.

Ada95 includes a Distributed Systems Annex (DSA) which defines several
extensions allowing a user to write a distributed system entirely in
Ada, using Ada packages as the definition of remote procedure call or
remote method call on distributed objects. Ada95 distributed systems
model is close to Modula-3's one and Java/RMI's one is similar to
Ada95's one. In these languages, the IDL is replaced by a subset of the
language. Therefore, the language supports both remote procedure calls
and remote object method invocations transparently.

A program written in such a language is supposed to communicate with a
program written in the same language, but this restriction gives rise to
several useful consequences. The language can provide more powerful
features because it is not constrained by the common features available
in all host languages. In Ada95, the user will define a specification of
remote services and implement them exactly as he would for ordinary,
non-distributed services. His Ada95 environment will compile them to
produce a stub file (on the caller side) and a skeleton file that
automatically includes the services body (on the receiver
side). Creating objects, obtaining or registering object references or
adapting the object skeleton to the user object implementation are made
transparent because the language environment has a full control on the
development process.

Comparing with multi-thread programming once again, the language
extension solution is equivalent to the solution adopted for tasking
facilities in Ada.  Writing a distributed application is as simple as
writing a concurrent application: there is no binding consideration and
no code to wrap.  The language and its run-time system take care of
every issue that would divert the programmer's attention from the
application domain.

@node The Distributed System Annex, Architecture of A DSA Application, Introduction To Distributed Systems, Tutorial on the Distributed Systems Annex
@section Overview of Ada95 Distributed System Annex

The basic idea of the Distributed Systems Annex (DSA) is to allow a user
to develop his application the same way whether this application is
going to be executed as several programs on a distributed system or as a
whole program on a non-distributed system. The DSA has been designed so
as to minimize the changes required to the source code of a program, in
converting it from an ordinary non-distributed program, to a distributed
program.

The easiest way to start with DSA is certainly to develop the
application on a non-distributed system. Of course, the design of the
application should take into account the fact that some units are going
to be accessed remotely. In order to write an Ada95 distributed program,
it is necessary for the user to categorize certain library level
compilation units of the application program, by inserting
categorization pragmas into their specification. The units which require
categorization are typically those which are called remotely, or ones
which provide types used in remote calls.

Therefore, these units must contain only a restricted set of Ada
entities. For instance, if the distributed system has no shared memory,
shared variables should be forbidden. To ensure such restrictions, the
DSA provides several categorization pragmas in order to reduce the set
of entities one can declare in a given unit.

Of course, you can develop the non-distributed application with your
usual software engineering environment. This is very important to note
that the user needs no specialized tools to develop his/her distributed
application. For instance, he can debug his/her application with his/her
usual debugger. A non-distributed program is not to be confused with a
distributed application composed of only one program. The later is built
with the help of the configuration tool and includes the communication
library.

The last step is to partition and to configure the non-distributed
application into a distributed application, that means multiple
partitions working cooperatively as part of a single Ada program. The
process of mapping the partitions of a program to the nodes in a
distributed system is called configuring the partitions of the
program. This is what GLADE is for.

The distributed version of the user application should work as is, but
even when a program can be built either as a non-distributed or a
distributed program using the same source code, there may still be
differences in program execution between the distributed and
non-distributed versions. These differences will be presented in others
sections.

Developping a non-distributed application in order to distribute it
later on is the natural approach for a novice. Of course, it is not
always possible to write a distributed application as a non-distributed
application. For instance, a client/server application does not belong
to this category because several instances of the client can be active
at the same time. It is very easy to develop such an application using
GLADE and we shall present to the expert how to do that in the following
sections.

@node Architecture of A DSA Application, Presentation Of Categorization Pragmas, The Distributed System Annex, Tutorial on the Distributed Systems Annex
@section Architecture of A Distributed Ada95 Application

A distributed system is an interconnection of one or more processing
nodes and zero or more storage nodes. A distributed program comprises
one or more partitions. A partition is an aggregate of library
units. Partitions communicate through shared data or RPCs. A passive
partition has no thread of control. Only a passive partition can be
configured on a storage node. An active partition has zero or more
threads of control and has to be configured on a processing node.

The library unit is the core component of an Ada95 distributed
application. The user can explicitly assign library units to a
partition. The partitioning is a post-compilation process. The user
identifies at compile time interface packages. These packages are
categorized using pragmas. Each of these pragmas allows to use one of
the following classical paradigms:

@itemize @bullet
@item Remote subprograms:
For the programmer, a remote subprogram call is similar to a regular
subprogram call. Run-time binding using access-to-subprogram types can
also be used with remote subprograms. These remote subprograms are
mostly declared in library units categorized as remote call interface
(RCI).
  
@item Distributed objects:
Remote-pointer particular access types can be defined, which designate
remote objects. When a primitive dispatching operation is invoked on an
object designated by a remote access, a remote call is performed
transparently on the partition on which the object was created. These
distributed objects are declared in library units categorized as remote
types (RT).
  
@item Shared objects:
Global data can be shared between active partitions, providing a
repository similar to a shared memory, a shared file system or a
database. Entry-less protected objects allow safe access and update on
shared objects. This feature is orthogonal to the notion of distributed
objects, which are only accessed through exported services. These shared 
objects are declared in library units categorized as shared passive (SP).

@end itemize

The remotely-called subprograms declared in a library unit categorized
as remote call interface (RCI) or remote types (RT) may be either
statically or dynamically bound. The partition on which a statically
bound remote subprogram is executed can be determine before the
call. This is a regular remote subprogram call. A remote method or a
dereference of access to remote subprogram are dynamically bound remote
calls because the partition on which the remote subprogram is executed
is determined by the parameters of the call.

In the following example, Data_1 and Data_2 are shared passive (SP)
library units. Data_1 is configured on a passive partition mapped on a
storage node. Partition_1 and Partition_2 are active partitions. Note
that under some circumstances, a partition, for instance Partition_2,
can be duplicated. To be duplicated, Unit_2 and Unit_3 which are
configured on Partition_2 have to provide only dynamically bound remote
subprograms. Otherwise, a partition calling a remote subprogram on
Unit_2 would not be able to statically determine where to perform the
remote call.
 
@smallexample
@group
       +-------------------------------+
       |         STORAGE NODE          |
       |                               |
       |       Passive_Partition       |
       |          +--------+           |
       |          | Data_1 |           |
       |          +--------+           |
       |                               |
       | File, Database, Shared Memory |
       +-------------------------------+
         /\                         /\
         ||                         ||
         \/                         \/
+-------------------------+ +-----------------+
|    PROCESSING NODE      | | PROCESSING NODE |
|                         | |                 |
| Partition_1 Partition_2 | |   Partition_2   |
| +--------+   +--------+ | |   +--------+    |
| | Unit_1 |   | Unit_2 | | |   | Unit_2 |    |
| | Data_2 |   | Unit_3 | | |   | Unit_3 |    |
| +--------+   +--------+ | |   +--------+    |
+-------------------------+ +-----------------+
          /\                        /\
          ||                        ||
          \/                        \/
=============================================
                    NETWORK
@end group
@end smallexample

@node Presentation Of Categorization Pragmas, Most Features in One Example, Architecture of A DSA Application, Tutorial on the Distributed Systems Annex
@section Presentation Of Categorization Pragmas

Library units can be categorized according to the role they play in a
distributed program. A categorization pragma is a library unit pragma
that restricts declarations, child units or semantic dependences of the
library unit to which it applies. There are several categorization
pragmas :

@itemize @bullet
@item Remote_Call_Interface
@item Remote_Types
@item Shared_Passive
@item Pure
@end itemize

The following paragraphs do not present the detailed semantics of these
pragmas. Their purpose is to give to the reader an intuitive overview of
what these pragmas are for. When a library unit is not categorized, this
unit is called a normal unit and cannot play a role in the distributed
application. Such a unit is duplicated on any partition in which it is
involved.

As a general remark, to avoid the development of a specific run-time
library for the DSA, the notion of remote rendez-vous has not been
introduced in Ada95. Therefore, task types and general protected types
are not allowed in the following Ada library units.

@menu
* Pragma Remote_Call_Interface::  
* Pragma Remote_Types::         
* Transmitting Dynamic Structure::  
* Pragma Shared_Passive::       
* More About Pragmas::          
@end menu

@node Pragma Remote_Call_Interface, Pragma Remote_Types, Presentation Of Categorization Pragmas, Presentation Of Categorization Pragmas
@subsection Pragma Remote_Call_Interface

@menu
* Overview of Remote Call Interface Units::  
* Regular Remote Subprograms (RCI)::  
* Remote Access To Subprograms (RAS)::  
* Remote Access To Class Wide Types (RACW)::  
* Summary on Remote Call Interface Units::  
@end menu

@node  Overview of Remote Call Interface Units, Regular Remote Subprograms (RCI), Pragma Remote_Call_Interface, Pragma Remote_Call_Interface
@subsubsection Overview of Remote Call Interface Units

Library units categorized with this pragma can declare subprograms to be
called and executed remotely.  This classical RPC operation is a
statically bound operation. In these units, clients and servers do not
share their memory space.

Dynamically bound calls are integrated with Ada capabilities to
dereference subprograms (remote access to subprogram - RAS) and to
dispatch on access-to-class-wide operands (remote access on class wide
types - RACW). These remote access types can be declared in a RCI
package.

A remote access type (RAS or RACW) can be viewed as a fat pointer or a
structure with a remote address and a local address. The remote address
describes for instance the host on which the entity has been created;
the local address describes the classical local memory address (like an
URL).

@node Regular Remote Subprograms (RCI), Remote Access To Subprograms (RAS), Overview of Remote Call Interface Units, Pragma Remote_Call_Interface
@subsubsection Regular Remote Subprograms (RCI)

In the following example, a bank offers several remote services:
Balance, Transfert, Deposit and Withdraw. On the caller side, the bank
client will use the stub files of unit Bank. On the receiver side, the
bank receiver will use the skeleton files of unit Bank including the
body of this package.

@smallexample
@group
with Types; use Types;
package Bank is
   pragma Remote_Call_Interface;

   function Balance
     (Customer : in Customer_Type;
      Password : in Password_Type)
      return Integer;

   procedure Transfer
     (Donator  : in Customer_Type;
      Password : in Password_Type;
      Deposit  : in Positive;
      Customer : in Customer_Type);

   procedure Deposit
     (Customer : in Customer_Type;
      Amount   : in Positive);

   procedure Withdraw
     (Customer : in Customer_Type;
      Password : in Password_Type;
      Amount   : in out Positive);

end Bank;
@end group
@end smallexample

@node Remote Access To Subprograms (RAS), Remote Access To Class Wide Types (RACW), Regular Remote Subprograms (RCI), Pragma Remote_Call_Interface
@subsubsection Remote Access To Subprograms (RAS)

In the following example, several mirroring banks offer their
services. Each bank register a reference to each of its services to a
central bank. A central bank client asks for a service of one of the
mirroring banks. In this purpose, the RCI unit Central_Bank defines
Balance_Type, a remote access to subprogram. An access type in a remote
unit has to be either remote access to subprogram or remote access to
class wide type.

Note that to get a remote access to subprogram the subprogram has to be
remote itself. Therefore, French_Bank is a RCI library unit.

@smallexample
@group
with Types; use Types;
package Central_Bank is
   pragma Remote_Call_Interface;

   type Balance_Type is access function
     (Customer : in Customer_Type;
      Password : in Password_Type)
      return Integer;

   procedure Register
      (Balance : in Balance_Type);

   function Get_Balance
      return Balance_Type;

   [...]  --  Same for other services
end Central_Bank;
@end group
@end smallexample

In the code below, a mirroring bank registers its services to the
central bank.

@smallexample
@group
with Types; use Types;
package French_Bank is
   pragma Remote_Call_Interface;

   function Balance
     (Customer : in Customer_Type;
      Password : in Password_Type)
      return Integer;

   [...]  --  Other services
end French_Bank;
@end group
@end smallexample

@smallexample
@group
with Central_Bank; use Central_Bank;
with Types; use Types;
package body French_Bank is

   function Balance
     (Customer : in Customer_Type;
      Password : in Password_Type)
      return Integer is
   begin [...] end Balance;

begin
   Register (Balance'Access);
   [...]  --  Register other services
end French_Bank;
@end group
@end smallexample

In the code below, a central bank client asks for a mirroring bank and
calls the Balance service of this bank by dereferencing a remote access
type.

@smallexample
@group
with Bank; use Bank;
procedure Client is
   B : Integer;
   C : Customer_Type;
   P : Password_Type;
begin
   B := Get_Balance.all (C, P);
end Client;
@end group
@end smallexample

@node Remote Access To Class Wide Types (RACW), Summary on Remote Call Interface Units, Remote Access To Subprograms (RAS), Pragma Remote_Call_Interface
@subsubsection Remote Access To Class Wide Types (RACW)

A bank client is now connected to a bank through a terminal. The bank
wants to notify a connected client with a message on the terminal when
another client grants him with a given amount of money.

@smallexample
@group
with Types; use Types;
package Terminal is
   pragma Pure;

   type Term_Type is abstract tagged limited private;

   procedure Notify
     (Terminal : access Term_Type;
      Donator  : in Customer_Type;
      Amount   : in Integer) is abstract;

private
   type Term_Type is abstract tagged limited null record;
end Terminal;
@end group
@end smallexample

In the code below, the RCI unit Bank defines Term_Access, a remote
access to class wide type. Term_Access becomes a reference to a
distributed object. In the next section, we will see how to derive
Term_Type, how to create a distributed object and how to use a reference
to it.

@smallexample
@group
with Terminal, Types; use Terminal, Types;
package Bank is
   pragma Remote_Call_Interface;

   type Term_Access is access all Term_Type'Access;

   procedure Register
     (Terminal : in Terminal_Access;
      Customer : in Customer_Type;
      Password : in Password_Type);

   [...]
end Bank;
@end group
@end smallexample

@node  Summary on Remote Call Interface Units,  , Remote Access To Class Wide Types (RACW), Pragma Remote_Call_Interface
@subsubsection Summary on Remote Call Interface Units

Remote call interface units:

@itemize @bullet
@item
Allow subprograms to be called and executed remotely

@item
Allow statically bound remote calls (remote subprogram)

@item
Allow dynamically bound remote calls (remote access types)

@item
Forbid variables and access types

@item
Prevent specification from depending on normal units

@end itemize

@menu
* Pragma Remote_Types::         
* Pragma Shared_Passive::       
* More About Pragmas::          
* Non-Distributed versus Distributed Applications::  
@end menu

@node Pragma Remote_Types, Transmitting Dynamic Structure, Pragma Remote_Call_Interface, Presentation Of Categorization Pragmas
@subsection Pragma Remote_Types

@menu
* Overview of Remote Types Units::  
* Distributed Object::          
@end menu

@node  Overview of Remote Types Units, Distributed Object, Pragma Remote_Types, Pragma Remote_Types
@subsubsection Overview of Remote Types Units

Unlike to RCI units, library units categorized with this pragma can
define distributed objects and remote methods on them. Both RCI and RT
units can define a remote access type described above (RACW). A
subprogram defined in a RT unit is not a remote subprogram. Unlike to
RCI units, a RT unit can be duplicated on several partitions in which
case all its entities are different with each other.

@node Distributed Object,  , Overview of Remote Types Units, Pragma Remote_Types
@subsubsection Distributed Object

If we want to implement the notification feature proposed in the
previous section, we have to derive Term_Type. Such a derivation is
possible in a remote types unit, New_Terminal. Any object of type
New_Term_Type becomes a distributed object and any reference to such an
object becomes a fat pointer or a reference to a distributed object.

@smallexample
@group
with Types, Terminal;
use Types, Terminal;
package New_Terminal is
   pragma Remote_Types;

   type New_Term_Type is
      new Term_Type with null record;

   procedure Notify
     (Terminal : access New_Term_Type;
      Donator  : in Customer_Type;
      Amount   : in Integer);
end New_Terminal;
@end group
@end smallexample

In the code below, a client registers his terminal to Bank. Therefore,
when any donator grants him with a given amount of money, Bank is able
to notify this client of this granting operation.

@smallexample
@group
with New_Terminal, Bank, Types;
use New_Terminal, Bank, Types;
procedure Client_2 is
   T2 : aliased New_Term_Type;
   C2 : Customer_Type := [...];
   P2 : Password_Type := [...];
begin
   Register (T2'Access, C2, P2);
   [...]
end Client_2;
@end group
@end smallexample

In the code below, a second client, the donator, registers his terminal
to the bank and executes a transfer to the first client.

@smallexample
@group
with New_Terminal, Bank, Types;
use New_Terminal, Bank, Types;
procedure Client_1 is
   T1 : aliased New_Term_Type;
   C1 : Customer_Type := [...];
   P1 : Password_Type := [...];
   C2 : Customer_Type := [...];
begin
   Register (T1'Access, C1, P1);
   Transfer (C1, P1, 100, C2);
end Client_1;
@end group
@end smallexample

In the code below, we describe the general design of Transfer. Classical
operations of Withdraw and Deposit are performed. Then, Bank retrieves
the terminal of the granted client and invoke a dispatching operation by
dereferencing a distributed object Term. The reference is analyzed and
the execution of this operation occurs on the partition to which the
distributed object belongs.

@smallexample
@group
package body Bank is
   procedure Register ([...]) is
   begin
      [...]; -- Save customer and terminal in name table. 
   end Register;

   procedure Transfer ([...]) is
      Term : Term_Access := [...]; -- Find customer terminal.
   begin
      Withdraw ([...]);
      Deposit  ([...]);
      Notify (Term, Donator, Amount); -- Notify on C2 terminal.
   end Transfer;
   
   [...]
end Bank;
@end group
@end smallexample

@node Transmitting Dynamic Structure, Pragma Shared_Passive, Pragma Remote_Types, Presentation Of Categorization Pragmas
@subsection Transmitting Dynamic Structure

General access types are forbidden in public part of a remote types
unit. But this would be too restrictive. It is possible to define
private general access types as long as the user provides its
marshalling procedures. The code below describes how to transmit a
linked structure.

@smallexample
@group
with Ada.Streams; use Ada.Streams;
package String_FIFO is
   pragma Remote_Types;

   type List is private;
   procedure Append (L : access List; O : in String);
   function  Delete (L : access List) return String;

private
   type String_Access is access String;

   type Node;
   type List is access Node;

   type Node is record
      Content : String_Access;
      Next    : Node_Access;
   end record;

   type List is new Node_Access;
   procedure Read  (S : access Root_Stream_Type'Class; L : out List);
   procedure Write (S : access Root_Stream_Type'Class; L : in List);
   for List'Read use Read;
   for List'Write use Write;
end String_FIFO;
@end group
@end smallexample

The code below provides an implementation of the marshalling operations
defined above:

@smallexample
@group
package body String_FIFO is
   [...]

   procedure Read (S : access Root_Stream_Type'Class; L : out List) is
   begin
      if Boolean'Input (S) then
         L := new Node;
         L.Content := new String'(String'Input (S));
         List'Read (S, L.Next);
      else
         L := null;
      end if;
   end Read;

   procedure Write (S : access Root_Stream_Type'Class; L : in List) is
   begin
      if L = null then
         Boolean'Output (S, False);
      else
         Boolean'Output (S, True);
         String'Output (S, L.Content.all);
         List'Write (S, L.Next);
      end if;
   end Write;
end String_FIFO;
@end group
@end smallexample

@menu
* Summary on Remote Types Units::  
@end menu

@node  Summary on Remote Types Units,  , Transmitting Dynamic Structure, Transmitting Dynamic Structure
@subsubsection Summary on Remote Types Units

Remote types units:

@itemize @bullet
@item
Allow to define distributed objects

@item
Allow dynamically bound remote calls (remote access type)

@item
Allow general access type (with marshalling subprograms)

@item
Allow unit duplication (like normal units)

@item
Prevent specification from depending on normal units

@end itemize

@node Pragma Shared_Passive, More About Pragmas, Transmitting Dynamic Structure, Presentation Of Categorization Pragmas
@subsection Pragma Shared_Passive

@menu
* Overview of Shared Passive Units::  
* Summary on Shared Passive Units::  
@end menu

@node  Overview of Shared Passive Units, Summary on Shared Passive Units, Pragma Shared_Passive, Pragma Shared_Passive
@subsubsection Overview of Shared Passive Units

The entities declared in such categorized unit library are to be mapped
on a shared address space (file, memory, database). When two partitions
use such a library unit, they can communicate by reading or writing the
same variable. This supports the shared variables paradigm. Entry-less
protected objects declared in these units provide an atomic access to
some shared data, somehow like in a transaction.

@subsubsection Shared and Protected Objects

In the code below, we define two kinds of shared
objects. External_Synchronization requires that the different partitions
updating this data synchronize to avoid conflicting operations on shared
objects. Internal_Synchronization provides a way to get an atomic
operation on shared objects. Note that only entry-less subprograms are
allowed in a shared passive unit.

@smallexample
@group
package Changes is
   pragma Shared_Passive;
 
   Max : Positive := 10;
   type Index_Type is range 1 .. Max;
   type Rate_Type is new Float;

   type Rates_Type is array (Index_Type) of Rate_Type;

   External_Synchronization : Rates_Type;

   protected Internal_Synchronization is
      procedure Set
        (Index : in Index_Type;
         Rate  : in Rate_Type);
      
      procedure Get
        (Index : in Index_Type;
         Rate  : out Rate_Type);
   private
      Rates : Rates_Type;
   end Internal_Synchronization;
end Changes;
@end group
@end smallexample

@node  Summary on Shared Passive Units,  , Overview of Shared Passive Units, Pragma Shared_Passive
@subsubsection Summary on Shared Passive Units

@itemize @bullet
@item
Allow direct access to data among different partitions

@item
Allow support on shared (distributed) memory

@item
Allow memory protection use for entryless protected objects

@item
Prevent specification from depending on normal units

@end itemize

@node More About Pragmas,  , Pragma Shared_Passive, Presentation Of Categorization Pragmas
@subsection More About Pragmas

In RT or RCI units, variables are forbidden and general access types
are allowed as long as their marshaling subprograms are provided. Any
exception raised in remote method or subprogram call is propagated to
the caller.

A pragma All_Calls_Remote in a RCI unit can force a remote procedure
call to be routed through the communication subsystem even for a local
call. This allows to debug an application in a non-distributed
situation that is very close to the distributed one.
  
A pragma Asynchronous allows statically and dynamically bound remote
calls to be executed asynchronously. An asynchronous procedure doesn't
wait for the completion of the remote call and lets the caller
continue its execution path. The procedure must have only @b{in}
parameters and any exception raised during the execution of the remote
procedure is lost.
  
Any of these categorized units can be generic. Instances of these
generic packages can be either categorized or not. In the latter, such
a unit loses its categorization property.

Each categorization pragma has very specific visibility rules. As a
general rule, RCI > RT > SP > Pure. That means that a
Remote_Types package can make visible in its specification only
Remote_Types, Shared_Passive and Pure units.

@node Most Features in One Example, Non-Distributed versus Distributed Applications, Presentation Of Categorization Pragmas, Tutorial on the Distributed Systems Annex
@section Most Features in One Example

The example shown on the following figure highlights most of
the features of DSA. The general system is based on a set of factories
and workers and a storage.  Each entity is a partition itself. A
factory hires a worker from a pool of workers (hire - 1) and assigns a
job (query - 2) to him. The worker performs the job and saves the
result (reply - 3) in a storage common to all the factories.  The
worker notifies the factory of the end of his job (notify - 4).

@format
@group
@t{
+-------------+               +-------------++-------------++-------------+
|  Partition  |               |  Partition  ||  Partition  ||  Partition  |
|             |               |             ||             ||             |
|+-----------+|               |+-----------+||+-----------+||+-----------+|
||One_Factory||               ||  Storage  ||||  Workers  ||||One_Factory||
|+-----------+|               |+-----------+||+-----------+||+-----------+|
|      *      |               |             |+-------------+|      *      |
|      \      |               |             |       ^       |      /      |
|      /      |               |             |       |       |      \      |
|      +...............       |             |       +----(Hire)----+      |
|      +----(Query)---+       |             |       +----(Query)---+      |
|      \      |       |       |             |       |       |      /      |
|      /      |       v       |             |       v       |      \      |
|      \      |+-------------+|             |+-------------+|      /      |
|      /      ||  Partition  ||             ||  Partition  ||      \      |
|      \      ||             ||             ||             ||      /      |
|      /      |+------------+||             ||+-----------+||      \      |
|      *      |||One_Worker |||             |||One_Worker |||      *      |
|      ^      ||+-----------+||     ^ ^     ||+-----------+||      ^      |
+------|------++------|------++-----|-|-----++------|------++------|------+
       |              |             | |             |              |
       |              |             | |             |              |
       |              +---(Reply)---+ +---(Reply)---+              |
       +---(Notify)---+                             +---(Notify)---+
}
@end group
@end format

@smallexample
@group
package Storage is
   pragma Shared_Passive;

   protected Queue is
      procedure Insert (Q, R : Integer);
      procedure Remove
        (Q : in Integer;
         R : out Integer);
   private
      -- Declaration not shown
   end Queue;
end Storage;
@end group
@end smallexample

When a worker has achieved his job, the result should be saved in a
common storage. To do this, we define a protected area in SP package
Storage (see sample above). Two entry-less protected objects
ensure atomic access on this area.

@smallexample
@group
with Storage; use Storage;
package Types is
   pragma Remote_Types;

   type Notify is
      access procedure (Q : Integer);
   pragma Asynchronous (Notify);

   type Worker is
      abstract tagged limited private;
   procedure Assign
     (W : access Worker;
      Q : in Integer;
      N : in Notify) is abstract;

   type Any_Worker is
      access all Worker'Class;
   pragma Asynchronous (Any_Worker);

private
   -- Declaration not shown
end Types;
@end group
@end smallexample

Types is a Remote_Types package that defines most of the remote services
of the above system (see sample above). First, we define a way for the
workers to notify the end of his job.  This callback mechanism is
implemented using RAS Notify.

@smallexample
@group
with Types, Storage; use Types, Storage;
package One_Worker is
   pragma Remote_Types;

   type G1_Worker is
      new Worker with private;

   procedure Assign
     (W : access G1_Worker;
      Q : Integer;
      N : Notify);
private
   -- Declaration not shown
end One_Worker;
@end group
@end smallexample

We define an abstract tagged type Worker which is intended to be the
root type of the whole distributed objects hierarchy. Assign allows a
factory to propose to a worker a job and a way to notify its employer
the end of this job. Any_Worker is a remote access to class wide type
(RACW). In other words, it is a reference to a distributed object of any
derived type from Worker class.

@smallexample
@group
with Types, Storage; use Types, Storage;
with One_Worker; use One_Worker;
package Another_Worker is
   pragma Remote_Types;

   type G2_Worker is
      new G1_Worker with private;

   procedure Assign
     (W : access G2_Worker;
      Q : Integer;
      N : Notify);
private
   -- Declaration not shown
end Another_Worker;
@end group
@end smallexample

G1_Worker is derived from type Worker and Assign is overridden. Sample
above shows how to derive a second generation of workers G2_Worker from
the first generation G1_Worker. As mentioned above, this RT package can
be duplicate on several partitions to produce several types of workers
and also several remote workers.

@smallexample
@group
with Types; use Types;
package Workers is
   pragma Remote_Call_Interface;

   procedure Insert (W : in  Any_Worker);
   procedure Remove (W : out Any_Worker);
end Workers;
@end group
@end smallexample

In sample above, we define an unique place where workers wait for
jobs. Workers is a Remote_Call_Interface package with services to hire
and free workers. Unlike to Remote_Types packages, Remote_Call_Interface
packages cannot be duplicated.

@smallexample
@group
with Storage; use Storage;
generic
package Factory is
   pragma Remote_Call_Interface;

   procedure Notify (Q : Integer);
   pragma Asynchronous (Notify);
end Factory;
@end group
@end smallexample

@smallexample
@group
with Factory;
package One_Factory is new Factory;
pragma Remote_Call_Interface (One_Factory);
@end group
@end smallexample

In order to use even more DSA features, Factory is defined as a generic
RCI package (see sample above). Any instantiation defines a new factory
(see sample above). To be RCI, this instantiation has to be categorized
once again.

@node Non-Distributed versus Distributed Applications,  , Most Features in One Example, Tutorial on the Distributed Systems Annex
@section Non-Distributed versus Distributed Applications

A sequential application may have a different behavior whether it is
configured to be a distributed program or not. Let's take the example
below.

@menu
* Code Example::                
* Execution in Non-Distributed System::  
* Execution in Distributed System::  
@end menu

@node Code Example, Execution in Non-Distributed System, Non-Distributed versus Distributed Applications, Non-Distributed versus Distributed Applications
@subsection Code Example
@smallexample
@group
package RCI_1 is                    package RCI_2 is
   pragma Remote_Call_Interface;       pragma Remote_Call_Interface;
   procedure P (X : Integer);          procedure P (X : Integer);
   pragma Asynchronous (P);            pragma Asynchronous (P);         
end RCI_1;                          end RCI_2;
@end group
@end smallexample

@smallexample
@group
with RCI_2;                         
package body RCI_1 is               package body RCI_2 is
                                       V : Integer := 0;
   procedure P (X : Integer) is        procedure P (X : Integer) is
   begin                               begin
      RCI_2.P (X);                        V := X;
   end P;                              end P;
end RCI_1;                          end RCI_2;
@end group
@end smallexample

@smallexample
@group
with RCI_1, RCI_2;
procedure Main is
begin
   RCI_1.P (1);
   RCI_2.P (2);
end Main;
@end group
@end smallexample

@node Execution in Non-Distributed System, Execution in Distributed System, Code Example, Non-Distributed versus Distributed Applications
@subsection Execution in Non-Distributed System

@smallexample
@group
RCI_1.P(1)
   |
  [1]
   |
   v
RCI_2.P(1) - [2] -> V = 1
   |
  [3]
   |
   v
RCI_2.P(2) - [4] -> V = 2
@end group
@end smallexample

@node Execution in Distributed System,  , Execution in Non-Distributed System, Non-Distributed versus Distributed Applications
@subsection Execution in Distributed System

@smallexample
@group
+-------------+     +-------------+     +-------------+ 
| Partition 1 |     | Partition 2 |     | Partition 3 |
+-------------+     +-------------+     +-------------+ 

RCI_1.P(1) - [1] -> RCI_2.P(1) 
   |                   |
  [2]                  |
   |                   |
   v                   
RCI_2.P(2) ---------- [3] ------------> RCI_2.P(2) - [4] -> V = 2

                       |
                       v
                    RCI_2.P(1) - [5] -> RCI_2.P(1) - [6] -> V = 1 
@end group
@end smallexample

@node Getting Started With GLADE, Index, Tutorial on the Distributed Systems Annex, Top
@chapter Getting Started With GLADE

This chapter describes the usual ways of using GLADE to compile Ada
distributed programs.

@node Index,  , Getting Started With GLADE, Top
@unnumbered Index

@printindex cp

@contents

@bye
