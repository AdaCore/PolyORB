\input texinfo @c -*-texinfo-*-
@setfilename glade_ug.info
@settitle GLADE User's Guide
@setchapternewpage odd
@syncodeindex fn cp

@titlepage

@title GLADE User's Guide
@subtitle GLADE, GNAT Library for Ada Distributed Environment
@subtitle Version 1.02 (DRAFT)
@subtitle April 13, 1997
@author Laurent Pautet

@page
@vskip 0pt plus 1filll

@copyright{} Copyright 1997-1997, Ada Core Technologies, Inc.

GLADE is free software; you can redistribute it and/or modify it under
terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version. GNAT is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANT
ABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
License for more details.  You should have received a copy of the GNU
General Public License along with GNAT; see file COPYING. If not, write
to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

@end titlepage

@ifinfo
@node Top, About This Guide,, (DIR)
@top GLADE User's Guide

GLADE is the GNAT implementation of Distributed Systems Annex.

@menu
* About This Guide::            
* Short Tutorial on Distributed System Annex::
* Getting Started With GLADE::
* The GLADE Configuration Language::
* The GLADE Building Model::
* The GNATDIST Switches::
* The GLADE Execution Model::
* Advanced Features::
* Extended Examples::
* Index::                       

 --- The Detailed Node Listing ---

About This Guide

* What This Guide Contains::    
* What You Should Know Before Reading This Guide::  
* Related Information::         
* Conventions::                 

Short Tutorial on the Distributed Systems Annex

* Categorization Pragmas::
* Using The Facilities Of The Distributed System Annex::
* Comparisons With Other Existing Standards::
* Simple Exaple : Hello_World::
* Client / Server Example : Simple Bank::

Getting Started With GLADE

* Building A Non-Distributed Application::
* Configuring The Distributed Application::
* Running The Distributed Application::

The GLADE configuration language

* Predefined Types::
* Predefined Operations::
* Predefined Attributes::
* Predefined Pragmas::
* Consistency Checks::

The GLADE Building Model

* Parsing The Configuration File::
* Generating Stub Ada Files::
* Generating Stub Ada Files::
* Generating Partition Ada Files::
* Linking A Partition::

The GNATDIST Switches

The GLADE Execution Model

* Remote Shells
* Boot Server
* Starter Program
* Filtering
* Version Checks

Advanced Features

* Multiple Platforms
* Message Passing Layer
* Replicated Partitions
* Priority

Internals

* Debugging Distributed Applications
* Configuring GLADE For Embedded Systems

Extended Examples

@end menu
@end ifinfo

@node Short Tutorial on the Distributed Systems Annex
@chapter Short Tutorial on the Distributed Systems Annex

@menu
* Using The Facilities Of The Distributed System Annex::
* Categorization pragmas::
* Comparisons With Other Existing Standards::
* Simple Exaple : Hello_World::
* Client / Server Example : Simple Bank::
@end menu

@node Using The Facilities Of The Distributed System Annex
@section Using The Facilities Of The Distributed System Annex

The basic idea of the Distributed Systems Annex is to allow a user to
develop his application the same way whether this application is going
to be executed as several programs on a distributed system or as a whole
program on a non-distributed system. The Distributed Systems Annex has
been designed so as to minimize the changes required to the source code
of a program, in converting it from an ordinary non-distributed program,
to a distributed program.

The first step is to develop the application on a non-distributed
system. Of course, the design of the application should take into
account the fact that some units are going to be accessed remotely. In
order to write an Ada 95 distributed program, it is necessary for the
user to categorize certain library level compilation units of the
application program, by inserting categorization pragmas into them. The
units which require categorization are typically those which are called
remotely, or ones which provide types used in remote calls.

Therefore, these units must contain only a restricted set of Ada
entities. For instance, if the distributed system has no shared memory,
shared variables should be forbidden. To ensure such restrictions, the
Distributed System Annex provides several categorization pragmas in
order to reduce the set of entities one can declare in a given unit.

The second step is to develop the non-distributed application with your
usual software engineering environment. This is very important to note
that you don't need to acquire specialized tools to develop your
distributed application. For instance, you can debug your application
with your usual debugger. A non-distributed program is not to be
confused with a distributed application composed of only one partition
program. The later is built with the help of the configuration tool and
includes the communication library.

The third step is to partition and to configure your non-distributed
application into a distributed application, that means multiple
partitions working cooperatively as part of a single Ada program. The
process of mapping the partitions of a program to the nodes in a
distributed system is called configuring the partitions of the
program. This is what GLADE is for.

The distributed version of the user application should work as is, but
even when a program can be built either as a non-distributed or a
distributed program using the same source code, there may still be
differences in program execution between the distributed and
non-distributed versions. These differences will be presented in others
sections.

@node Categorization pragmas
@section Categorization pragmas

Library units can be categorized according to the role they play in a
distributed program. A categorization pragma is a library unit pragma
that restricts the declarations, child units, or semantic dependences of
the library unit to which it applies. There are several categorization
pragmas :

@enumerate
@item Remote_Call_Interface
@item Remote_Types
@item Shared_Passive
@item Pure
@end enumerate

When a library unit is not categorized, this unit is called a normal
unit. The following paragraphs do not present the detailed semantics of
these pragmas. Their purpose is to give to the reader an intuitive
overview of what these pragmas are for.

As a general remark, to avoid the development of a specific run-time
library for the Distributed System Annex, the notion of remote
rendez-vous has not been introduced in the Distributed System
Annex. Therefore, task types and protected types are not allowed in the
following Ada library units.

@node Pragma Remote_Call_Interface
@subsection Pragma Remote_Call_Interface

This pragma is probably the most important pragma of this set of pragmas
as it provides several ways to implement Remote Procedure Call. When a
pragma Remote_Call_Interface occurs in the specification of an Ada
package, then this package is said to be RCI (Remote Call Interface). As
this pragma is used to implement RPC features, entities forbidden in
this model are also forbidden in such a unit. This applies to variables
and to most access types. 

A distributed program retains the same type safety as the equivalent
single partition program.

If an exception is propagated by a remotely called subprogram, and the
call is not an asynchronous call (see next subsection), the
corresponding exception is reraised at the point of the remote
subprogram call. If a given exception is propagated by a remote
subprogram call, but the exception does not exist in the calling
partition, the exception can be handled by an others choice or be
propagated to and handled by a third partition.

@node Plain Remote Procedure Call
@subsubsection Plain Remote Procedure Call

Any subprogram declared in a RCI package specification becomes a remote
subprogram. This package specification acts as an IDL specification. In
other terms, Ada acts as an IDL.

@example 
package RCI is 
   pragma Remote_Call_Interface;
   A_Constant : constant := 0;
   procedure A_Remote_Procedure (X : in out Integer);
   function A_Remote_Function return String;
   An_Exception : exception;
end RCI;
@end example

Pragma Asynchronous can be applied to any subprogram of a RCI package as
long as this subprogram has only "in" parameters. In this case, the
subprogram calls is allowed to return prior to the completion of
subprogram execution. In this case, any exception is lost.

@example
package RCI is
   function Name return String;
   procedure Set (Variable : String; Value : Integer);
   pragma Asynchronous (Name, Set);
end RCI;
@end example

@node Remote Access To Subprogram
@subsubsection Remote Access To Subprogram

@node Remote Access To Class Wide
@subsubsection Remote Access To Class Wide

@page

@node Non-Distributed versus Distributed Applications
@subsubsection Non-Distributed versus Distributed Applications

A sequential application may have a different behaviour whether it is
configured to be a distributed program or not. Let's take the following
example:

@smallexample
package RCI_1 is                    package RCI_2 is
   pragma Remote_Call_Interface;       pragma Remote_Call_Interface;
   procedure P (X : Integer);          procedure P (X : Integer);
   pragma Asynchronous (P);            pragma Asynchronous (P);         
end RCI_1;                          end RCI_2;

with RCI_2;                         
package body RCI_1 is               package body RCI_2 is
                                       V : Integer := 0;
   procedure P (X : Integer) is        procedure P (X : Integer) is
   begin                               begin
      RCI_2.P (X);                        V := X;
   end P;                              end P;
end RCI_1;                          end RCI_2;

with RCI_1, RCI_2;
procedure Main is
begin
   RCI_1.P (1);
   RCI_2.P (2);
end Main;
@end smallexample

@page
Execution of Two Asynchronous Procedures in Non-Distributed Systems:

@smallexample
RCI_1.P(1)
   |
  [1]
   |
   v
RCI_2.P(1) - [2] -> V = 1
   |
  [3]
   |
   v
RCI_2.P(2) - [4] -> V = 2
@end smallexample

@*
Execution of Two Asynchronous Procedures in Distributed Systems:

@smallexample
+-------------+     +-------------+     +-------------+ 
| Partition 1 |     | Partition 2 |     | Partition 3 |
+-------------+     +-------------+     +-------------+ 

RCI_1.P(1) - [1] -> RCI_2.P(1) 
   |                   |
  [2]                  |
   |                   |
   v                   
RCI_2.P(2) ---------- [3] ------------> RCI_2.P(2) - [4] -> V = 2

                       |
                       v
                    RCI_2.P(1) - [5] -> RCI_2.P(1) - [6] -> V = 1 
@end smallexample

@node Pragma Remote_Types
@subsection Pragma Remote_Types

@node Getting Started With GLADE
@chapter Getting Started With GLADE

This chapter describes the usual ways of using GLADE to compile Ada
distributed programs.

@node Index
@unnumbered Index

@printindex cp

@contents

@bye
