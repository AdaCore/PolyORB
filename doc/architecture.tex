%% Architecture de DROOPI
%% $Id$

\documentclass[12pt,a4paper]{article}
\usepackage{slashbox}
\usepackage{interop}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[francais]{babel}
\usepackage{graphics}
\usepackage{psfig}
\usepackage{array}

\title{Architecture de DROOPI}
\author{Thomas Quinot}

\begin{document}

\maketitle

\section{Position du problème}

\subsection{Contexte}
\label{sec:contexte}
% Les entités qu'on va être amenés à faire coopérer

On considère un ensemble d'objets (entités) que l'on souhaite faire interopérer,
par exemple~:
\begin{itemize}
\item des serveurs DSA~;
\item des clients DSA~;
\item des serveurs CORBA~;
\item des clients CORBA.
\end{itemize}

Toute entité est rattachée à un ORB qui est chargé d'assurer les fonctions
liées à la répartition nécessaires aux besoins de l'entité.

Ainsi, une entité DSA (client ou serveur) peut être rattachée à un ORB GLADE
(le code existant), ou bien à un ORB générique DROOPI (possédant une
personnalité DSA).

De même, une entité CORBA (client ou serveur) peut être rattachée à un ORB CORBA
(AdaBroker par exemple), ou bien à un ORB générique DROOPI (possédant
une personnalité CORBA).

Un ORB possède deux façades~:
\begin{itemize}
\item une façade qu'il présente aux entités (clients
  ou serveurs) qui lui sont rattachées~;
\item une façade qu'il présente à d'autres ORBs à travers un
  réseau de communication et des protocoles de communication inter-ORB.
\end{itemize}

Chacune de ces façades possède plusieurs variantes (par exemple DSA, CORBA)~;
le choix d'une variante pour une façade détermine une personnalité sur cette façade.

L'objectif de DROOPI est de découpler ces deux façades. D'une part, une entité
peut se rattacher à un ORB DROOPI au moyen d'une des personnalités de cet ORB
(personnalité «~applicative~» paramétrant la façade présentée aux objets de
l'application).

D'autre part, un ORB distants peut invoquer une méthode sur cette entité en
transmettant une demande d'invocation à DROOPI au moyen d'une (autre)
personnalité (personnalité «~protocolaire~» paramétrant la façade présentée
aux autres ORBs \emph{via} un réseau de communication).

\subsection{Domaine}
% Limitation du scope de l'étude

Nous souhaitons limiter notre étude à un ensemble de cas précis.

Nous identifions les cas d'interopérations possibles par une matrice~:

{
\newcommand{\RH}[1]{\raisebox{-1ex}[0pt][1em]{\makebox[1em][l]{\rotatebox{45}{#1}}}}
\def\myrule{\relax}
\vspace{2cm}
\begin{tabular}{l|*{4}{c!{\myrule}}@{\gdef\myrule{\vline}}}
\backslashbox{Client}{Serveur}
& \RH{DSA DROOPI}
& \RH{DSA GLADE}
& \RH{CORBA DROOPI}
& \RH{CORBA AdaBroker}  \\ \hline\hline
DSA DROOPI      & 3 & 6 & 5 & 5  \\\hline
DSA GLADE       & 6 & 1 & 8 & 8  \\\hline
CORBA DROOPI    & 4 & 7 & 2 & 2  \\\hline
CORBA AdaBroker & 4 & 7 & 2 & 1  \\\hline
\end{tabular}
}

\begin{enumerate}
\item %1
  Ne fait pas intervenir DROOPI.
\item %2
  La personnalité CORBA de DROOPI implémente les specs CORBA de l'OMG.
  Cela suppose un support par un compilateur IDL.
\item %3
  La personnalité DSA de DROOPI implémente l'annexe des systèmes
  répartis d'\ada{}. Cela suppose un support dans le compilateur.
\item %4
  Découplage des personnalités. Situation fonctionnellement
  équivalente (pour le développeur d'application répartie) à CIAO,
  mais sans avoir besoin d'un proxy.
\item %5
  Réciproque du précédent.
\item %6
  Suppose le support par DROOPI du protocole actuel de GLADE.
\item %7
  Suppose le support du protocole actuel de GLADE \emph{et} d'un
  mécanisme permettant de retransmettre une requête reçue par un subrogé
  «~serveur~» à un subrogé «~client~», pour continuation.\\
  Situation identique à CIAO (avec proxy).
\item %8
  Réciproqe du précédent.
\end{enumerate}

\section{Principes de l'architecture}
\subsection{Vue d'ensemble}

\begin{figure}
\begin{center}
\mbox{\psfig{file=droopi-arch.eps,width=10cm}}
\end{center}
\caption{Architecture DROOPI}
\label{fig:droopi-arch}
\end{figure}

La figure~\ref{fig:droopi-arch} donne une vue d'ensemble de
l'architecture retenue pour DROOPI.

%%  XXX explication du dessin

\subsection{Client}

Un client DROOPI dispose d'une description de service dans une
personnalité donnée. Cette description de service va permettre
de générer~:
\begin{itemize}
\item des stubs génériques~;
\item des stubs spécifiques (par ex. fonction de sérialisation
  d'un objet de type «~requête~»)~;
\item des fonctions de représentation des types de données
  manipulées.
\end{itemize}

Un serveur DROOPI dispose d'une description de service dans une
personnalité donnée. Cette description de service va permettre
de générer~:
\begin{itemize}
\item un squelette génériques~;
\item un squelette spécifique (fonction de désérialisation
  des objets requêtes)~;
\item des fonctions de représentation des types de données
  manipulées.
\end{itemize}

Si on souhaite supporter plusieurs familles de représentations
différentes (eg. CDR (CORBA) \emph{et} XDR (GLADE)), alors il faut disposer
des descriptions des types de données pour chaque personnalité
associée.

\subsection{Mécanisme d'interopérabilité}

Par un moyen à définir, l'utilisateur peut traduire des descriptions
de service d'une personnalité en descriptions de services d'une autre
personnalité. À partir des deux descriptions, un client de l'une
peut attaquer un serveur de l'autre.

Cette facette peut, dans un premier temps, être réalisée par traduction
manuelle. On laisse l'automatisation de cette phase à des travaux
annexes ou futurs.

\section{Conception d'une solution}
\subsection{Vue d'ensemble}

\begin{figure}
\begin{center}
\psfig{file=droopi-design.eps,width=15cm}
\end{center}
\caption{Conception DROOPI}
\label{fig:droopi-uml}
\end{figure}

La figure \ref{fig:droopi-uml} donne une vue d'ensemble de
l'implémentation de DROOPI. Elle est pilotée par des événements
échangés entre modules. En effet, le middleware ne doit pas imposer
l'ajout de nouvelles tâches dans une application qui n'en comporte pas.
Les activités de l'ORB ne doivent être déclenchées qu'en tant que de
besoin, lorsque l'application souhaite invoquer une méthode distante,
ou lorsqu'un message est reçu sur un canal de communication.

\subsection{Ordonnancement}

Un object \emph{Scheduler} (ordonnanceur) régit l'exécution des activités de l'ORB
en fonction des événements qui se produisent. Différentes politiques
d'ordonnancement peuvent être mises en {\oe}uvre. Elles sont matérialisées
par des objets dérivés de \emph{Tasking\_Policy}, auxquels l'ordonnanceur
délègue une partie de ses comportements.

\subsection{Couche applicative}

Les personnalités applicatives sont réalisées par concrétisation
d'un certain nombre de classes abstraites.

\begin{description}
\item[Object\_Adapter] un  «~annuaire d'objets~» qui associe
  des références logiques (\emph{Object\_References})
  aux implémentations concrètes (\emph{Servants})~;
\item[Object\_Reference] une information communicable,
  créée par un object adapter, qui contient un ou plusieurs
  profiles.
  Chaque profil désigne un point d'accès du service de transport
  sur lequel des requêtes peuvent être envoyées. Il contient
  également l'identité de l'object adapter qui a créé la référence,
  et l'identité de l'objet logique désigné.
\item[Servant] la classe racine de toutes les implémentations
  d'objets, i. e. de toute chose susceptible d'exécuter une
  méthode invoquée à distance.
\end{description}

Les classes \emph{Servant} et \emph{Object\_Reference} sont
éventuellement dérivées par chaque personnalité d'une façon qui
lui est propre, pour s'articuler avec les composants applicatifs.

\subsection{Couche protocolaire}

Les personnalités procotolaires sont réalisées par concrétisation
d'un certain nombre de classes abstraites.

\begin{description}
\item[Asynch\_Event\_Source] une source d'événements externes
  asynchrones, par exemple un descripteur de fichier qui peut
  participer à un appel à \emph{select(2)}~;
\item[Filter] une interface supportant le passage de messages
  dynamiquement typés à l'intérieur de DROOPI. Toute entité
  qui a besoin de participer à la gestion des communications
  avec d'autres ORBS implémente cette interface. Ainsi, les
  types concrets de messages échangés entre les entités peuvent
  être définis séparément, ce qui résout les problèmes de
  visibilité croisée.
%% XXX inclure un exemple succint.
\item[Transport\_Endpoint] une extrémité d'un canal de communication
  permettant d'échanger des messages avec un autre ORB.
  L'objet qui concrétise un TE peut également être vu comme une source
  d'événements asynchrones (\emph{AES\_View})~; l'interface
  \emph{Transport\_Endpoint} est la vue de cet objet qui est présentée
  aux couches supérieures du module de communication, tandis que la vue
  \emph{Asynchronous\_Event\_Source} présentée à l'ordonnanceur.
\item[Protocol] interface abstraite pour un protocole d'appel de méthode
  à distance (par exemple GIOP ou SOAP). Un \emph{Protocol} est une factory
  d'objets \emph{Session}.
\item[Session] incarne l'état d'une session ouverte d'un protocole.
  Cet objet effectue l'échange de messages nécessaire pour passer
  des demandes d'invocation de méthodes d'un ORB à l'autre.
\end{description}

\subsubsection{Transport endpoint (TE)}

Un point d'accès du service de transport.

$\leftrightarrow$ une socket de comm, un identificateur d'IPC.

Primitives~: open/read/write/close

\textbf{Comment ça se goupille pour produire des Data\_Units ?} Read et Write
pourraient accepter comme arguments des Data\_Units particulières. Un TE pourrait
être un «~pseudo-filtre~» (une protocol entity au sens de l'OSI...)

Doit pourvoir participer à un poll (e/s asynchrones, liées au mécanisme
de gestion des événements dans l'ORB) en s'intégrant dans une source d'événements
asynchrones.

Un point de terminaison connecté est associé à un seul protocole~\ref{sec:protocoles}.

Statut~: pas implémenté (utilisation directe des sockets). Il faut cacher les
sockets sous une abstraction qui puisse également accueillir un autre mécanisme
de communication (par ex. IPC SysV~: mémoire partagée, file de messages...)

\subsubsection{Transport service access point (TSAP)}

$\leftrightarrow$ une socket en écoute, un identificateur d'IPC.

Doit pouvoir participer à un poll.

Primitives~: bind/accept.

Un TSAP est associé à un seul protocole. Le TSAP agit comme une factory de TE.
Lorsqu'un TE est créé à partir d'un TSAP, le TE hérite du protocole de son TSAP
(une session de ce protocole est créée et liée au TE).

\subsubsection{Filtres}

Les TE produisent des données (reçues du réseau) et acceptent des données (à émettre
vers le réseau). Les réifiant ces échanges de données sont les Data\_Units.

Il peut être nécessaire d'intercaler des traitements de mise en forme des Data\_Unit entre
TE et sessions. C'est le rôle des objets abstraits «~filtres~». À un TSAP est associée
une pile de factories de filtres (dont la dernière, au sommet, définit le protocole
du TSAP). Lorsqu'une connexion est acceptée et un TE créé, chaque factory est invoquée
pour créer une pile d'instances de filtres qui sont chaînés. Ces filtres échangent
ensuite des Data\_Unit soit du bas de la pile (du TE) vers le haut (la session) (données
reçues), soit du haut de la pile vers le bas (données émises).

Un exemple typique de filtre est le délimiteur de messages~: lorsqu'un transport
offre un service de flux continu de données (par exemple une socket TCP), il est
nécessaire de délimiter les messages échangés à l'intérieur du flux (par exemple
en connaissant à l'avance la taille des messages qui vont être reçus, ou bien
au moyen de fanions placés aux extrémités des messages). Un filtre va recevoir
les Data\_Units issus du réseau (correspondant à des fragments de messages) et les
rassembler pour reformer des messages complets (tels qu'attendus par les sessions).

Un pseudo-filtre est associé à chaque type de TE (pour l'instant implémenté uniquement
pour les sockets) qui produit des Data\_Unit quand des données sont reçues sur le réseau,
et émet sur le réseau les Data\_Units acceptées.

De même, les sessions sont des pseudo-filtres qui acceptent les Data\_Units issues des couches
inférieures, et agissent en fonction des messages reçues (au lieu de les transmettre
comme Data\_Units aux couches supérieures).

Pour être honnête~: si on considère que le scheduler de l'ORB est la couche supérieure par
rapport aux sessions, et que l'objet Request est une Data\_Unit, alors la Session est juste un
filtre qui convertit des messages en requests et des replys en messages. À explorer.

Statut~: Droopi.Filters fournit l'abstraction des filtres et aussi les types concrets
de Data\_Units. Il faudrait séparer les deux et ne définir qu'un type Data\_Unit abstrait. Ensuite,
les Data\_Units concrètes seraient définies dans d'autres unités, qui ne seraient visibles que
là où c'est nécessaire (une Data\_Unit échangée entre les couches A et B ne serait visible que
par les unités implémentant A et B.)

\subsection{Objets communs}

\subsubsection{Synchronisation}

\begin{description}
\item[Droopi.Soft\_Links] Abstractions de toutes les constructions
  susceptibles de tirer la runtime de tasking si l'on se trouve dans
  un contexte multi-tâches.
\item[Droopi.Protected\_Objects] Implémentation des soft-links utilisant
  les objets protégés, pour le cas d'un ORB multi-tâches.
\item[Droopi.No\_Tasking] Implémentation vide des soft-links pour
  le cas d'un ORB mono-tâche.
\item[Droopi.Locks] Objets de haut niveau implémentés par-dessus les Soft\_Links
  et fournissant des abstractions plus évoluées.\\
  Exemple~: verrou lecteur-écrivain.\\
  Extension possible~: verrou avec priority ceiling.
\end{description}

\subsubsection{Découplage des facettes}

Comme exprimé en \ref{sec:contexte}, le middleware générique DROOPI lie des objets
d'applications avec une architecture de transport de messages. À ce titre, il
offre deux facettes de personnalitation~:
\begin{itemize}
\item l'interface avec les objets d'application («~personnalité applicative~»)~;
\item l'interface avec d'autres middlewares à travers l'architecture de transport
 («~personnalité protocolaire~»).
\end{itemize}

L'articulation entre ces deux facettes est l'objet Request. Cet objet représente, de manière
indépendante à la fois de la personnalité applicative et de la personnalité protocolaire,
une requête d'invocation d'une méthode sur un objet.

L'implémentation d'une personnalité applicative doit~:
\begin{itemize}
\item transformer une invocation de méthode en un objet Request, et livrer cet objet
  à l'ORB générique, puis prendre connaissance du résultat renvoyé par l'ORB générique
  et de le retransformer en retour d'invocation \emph{(côté client)}~;
\item recevoir de l'ORB générique des objets Request destiné à des objets locaux, effectuer
  les appels de méthode locaux correspondants, et retourner les résultats à l'ORB générique
  \emph{(côté serveur)}.
\end{itemize}

L'implémentation d'une personnalité protocolaire doit~:
\begin{itemize}
\item recevoir des Request de l'ORB générique, et les expédier sous forme de messages à
  d'autres ORBs, puis recevoir les messages en réponse~;
\item recevoir des messages d'invocation provenant d'autres ORBs, les transformer en Requests
  et les transmettre à l'ORB générique pour exécution, puis récupérer le résultat et l'expédier
  sous forme de message à l'ORB client.
\end{itemize}

\subsection{Objets des personnalités protocolaires}%
\label{sec:protocoles}

Cette section décrit les objets abstraits qui doivent être spécialisés pour offrir une personnalité
protocolaire.

\subsubsection{Sérialisation~: Droopi.Representations}

Pour tout type de données (existant dans le contexte d'une personnalité utilisateur)
il faut établir des fonctions de sérialisation (dans le contexte d'une personnalité protocole).

On va donc générer dans chaque personnalité utilisateur des fonctions de conversion
des données vers des types \emph{auto-descriptifs} de manière à ce que chaque encodeur
(dans une personnalité protocole) implémente (différemment) un même comportement générique.
Ces types auto-descriptifs seront similaires aux \emph{Any} de CORBA~; cette approche ressemble
à l'idée qui consiste à construire un ORB CORBA en partant de l'invocation dynamique.

Cela impose peut-être que le modèle de types de DROOPI (ie le modèle de description des types
auto-descriptifs) soit aussi riche que celui de DSA ($>$ CORBA) (notion par exemple d'argument
non-contraint pour lesquels une représentation particulière est nécessaire ??)

L'abstraction d'une méthode pour
représenter des données sous une forme transmissible sur un
réseau (i. e. la réification d'un algorithme de sérialisation).

Primitives~: conversion d'un Any (une donnée quelconque) en
un flot d'octets et vice-versa.

Exemples de dérivations concrètes possibles~: CDR, XDR.

\subsubsection{Protocole d'invocation~: Droopi.Protocols}

Droopi.Session est l'abstraction d'une connexion ouverte avec un autre
middleware, sur laquelle on peut émettre ou recevoir des requêtes d'invocation
de méthodes. Une session se situe au sommet d'une pile de filtres
liée à un TE.

Étant donnée une requête d'invocation de méthode
destinée à un objet (une instance de Request), la session
construit un message et transmet ce message à un middleware distant
afin que la requête soit exécutée.

Étant donnée un message reçu, la session construit une requête et la fait
exécuter par un servant local.

Les sessions sont créées à partir de factories appelées Protocols. Un protocole
est défini comme un moyen d'associer une session et une représentation à un TE.

%%  ./droopi-jobs.ads
%%  
%%  A Job is anything that can keep a task busy (like a Runnable
%%  in Java). This unit declares an abstract Job type, and a means
%%  to queue jobs for execution.
%%  
%%  ./sequences.ads
%%  ./sequences-bounded.ads
%%  ./sequences-unbounded.ads
%%  
%%  {Bounded,unbounded} variable length arrays (cf. CORBA.Sequences.
%%  Notionally based on Ada.Strings.Unbounded.)
%%  
%%  ----------
%%  
%%  Others are undocumented as of yet.
%%  
%%  ./droopi-representations-test.ads
%%  ./droopi-transport\_endpoints.ads
%%  ./droopi-protocols.ads
%%  ./droopi-sockets.ads
%%  ./droopi-setup.ads
%%  ./droopi-transport.ads
%%  ./droopi-requests.ads
%%  ./droopi-buffers.ads
%%  ./droopi-refs.ads
%%  ./droopi-opaque-chunk\_pools.ads
%%  ./droopi-opaque.ads
%%  ./droopi-no\_tasking.ads
%%  ./droopi-orb-task\_policies.ads
%%  ./droopi-obj\_adapters.ads
%%  ./droopi-surrogates.ads
%%  ./droopi-binding\_data.ads
%%  ./droopi-types.ads
%%  ./droopi-servers.ads
%%  ./droopi-protocols-echo.ads
%%  ./droopi-layers.ads
%%  ./broca-names.ads


\end{document}
