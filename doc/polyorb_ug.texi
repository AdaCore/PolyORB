\input texinfo @c -*-texinfo-*-

@c %**start of header

@c oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
@c
@c                                Style Guide
@c
@c  1. Always put a @noindent on the line before the first paragraph
@c     after any of these commands:
@c
@c          @chapter
@c          @section
@c          @subsection
@c          @subsubsection
@c          @subsubsubsection
@c
@c          @end smallexample
@c          @end itemize
@c          @end enumerate
@c
@c  2. DO NOT use @example. Use @smallexample instead.
@c     a) DO NOT use highlighting commands (@b{}, @i{}) inside an @smallexample
@c        context.  These can interfere with the readability of the texi
@c        source file.  Instead, use one of the following annotated
@c        @smallexample commands, and preprocess the texi file with the
@c        ada2texi tool (which generates appropriate highlighting):
@c        @smallexample @c ada
@c        @smallexample @c adanocomment
@c        @smallexample @c projectfile
@c     b) The "@c ada" markup will result in boldface for reserved words
@c        and italics for comments
@c     c) The "@c adanocomment" markup will result only in boldface for
@c        reserved words (comments are left alone)
@c     d) The "@c projectfile" markup is like "@c ada" except that the set
@c        of reserved words include the new reserved words for project files
@c
@c  3. Each @chapter, @section, @subsection, @subsubsection, etc.
@c     command must be preceded by two empty lines
@c
@c  4. The @item command should be on a line of its own if it is in an
@c     @itemize or @enumerate command.
@c
@c  5. DO NOT put trailing spaces at the end of a line.  Such spaces will
@c     cause the document build to fail.
@c
@c  6. DO NOT use @cartouche for examples that are longer than around 10 lines.
@c     This command inhibits page breaks, so long examples in a @cartouche can
@c     lead to large, ugly patches of empty space on a page.
@c
@c oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

@c $Id: //droopi/main/doc/polyorb_ug.texi#2 $

@setfilename polyorb_ug.info
@settitle PolyORB User's Guide

@include version.texi

@setchapternewpage odd
@syncodeindex fn cp

@c %**end of header

@titlepage

@title PolyORB User's Guide
@subtitle Version @value{VERSION}
@subtitle Document revision level @value{EDITION}
@subtitle Date: @value{UPDATED}
@author XXXX

@page
@vskip 0pt plus 1filll

Copyright @copyright{} 2003, XXX
This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

@end titlepage

@ifinfo
@node Top, Introduction to PolyORB, (dir), (dir)
@top PolyORB User's Guide

PolyORB User's Guide

Version @value{VERSION}

Date: @value{UPDATED}

Copyright @copyright{} 2003, XXX
This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are clearly
marked as alterations and (2) this copyright notice is included
unmodified in any copy.

@menu
* Introduction to PolyORB::

@detailmenu
 --- The Detailed Node Listing ---

@end detailmenu
@end menu

@end ifinfo

@c -------------------------------------------------------------------
@node Introduction to PolyORB
@chapter Introduction to PolyORB
@cindex PolyORB
@c -------------------------------------------------------------------


@section Distributed applications and middleware

@noindent
PolyORB aims at providing a uniform solution to build distributed
applications; relying either on industrial-strength middleware
standards such as CORBA, the Distributed System Annex of Ada 95,
distribution programming paradigms such as Web Services, Message
Oriented Middleware (MOM), or to implement application-specific
middleware.

Middleware provides a framework that hides the complex issues of
distribution, and offers the programmer high-level abstractions that
allow easy and transparent construction of distributed applications.
A number of different standards exist for creating object-oriented
distributed applications. These standards define two subsystems that
enable interaction between application partitions:

    * the API seen by the developer's applicative objects;

    * the protocol used by the middleware environment to interact with
      other nodes in the distributed application.

Middleware implementations also offer programming guidelines as well as
development tools to ease the construction of large heterogeneous
distributed systems. Many issues typical to distributed programming may
still arise: application architectural choice, configuration
or deployment. Since there is no "one size fits all" architecture,
choosing the adequate distribution middleware in its most appropriate
configuration is a key design point that dramatically impacts the
design and performance of an application.

Consequently, applications need to rapidly tailor middleware to the
specific distribution model they require. A distribution model is
defined by the combination of distribution mechanisms made available
to the application. Common examples of such mechanisms are Remote
Procedure Call (RPC), Distributed Objects or Message Passing. A
distribution infrastructure or middleware refers to software that
supports one (or several) distribution model, e.g.: OMG CORBA, Java
Remote Method Invocation (RMI), the Distributed System Annex of Ada
95, Java Message Service (MOM).


@section PolyORB: a generic middleware with an instance per distribution model

Typical middleware implementations for one platform support only one
set of such interfaces, pre-defined configuration capabilities and
cannot interoperate with other platforms. In addition to traditional
middleware implementations, PolyORB proposes an original architecture
to enable support for multiple interoperating distribution models in a
uniform canvas.

PolyORB is a polymorphic, reusable infrastructure for building or
prototyping new middleware adapted to specific application needs. It
provides a set of components on top of which various instances can be
elaborated. These instances (or personalities) are views on PolyORB
facilities that are compliant to existing standards, either at the API
level (application personality) or at the protocol level (protocol
personality). These personalities are mutually exclusive views of the
same architecture.

The decoupling of application and protocol personalities, and the
support for multiple simultaneous personalities within the same
running middleware, are key features required for the construction of
interoperable distributed applications. This allows PolyORB to
communicate with middleware that implement different distribution
standards: PolyORB provides middleware-to-middleware interoperability
(M2M).

PolyORB's modularity allows for easy extension and replacement of its
core and personality components, in order to meet specific requirements.
In this way, standard or application-specific personalities can be
created in a streamlined process, from early stage prototyping to
full-featured implementation. The PolyORB architecture also allows
the automatic, just-in-time creation of proxies between incompatible
environments.

@i{Note: PolyORB is the project formerly known as DROOPI, a Distributed
Reusable Object-Oriented Polymorphic Infrastructure}

@contents
@bye
