\chapter{Introduction}

\section{CORBA and the OMG}

\subsection{The abstract concepts}

\paragraph{}The {\bf O}bject {\bf M}anagement {\bf G}roup is a consortium created in 1989 
that put together more than 850 actors of the new economy :
contructors like Sun or IBM, software seller like Netscape, Inprise or Visigenic, users like Boeing or Alcatel and institutions or
universities like NASA, INRIA, LIFL. The goal of this group is to create standards for the integration of heterogeneous applications
on distributed systems using object oriented technologies. The key concepts are thus reusability, interoperability and portability
of software components.

\paragraph{}The key element of the OMG vision is CORBA : {\bf C}ommon {\bf O}bject {\bf R}equest {\bf B}roker {\bf A}rchitecture.
It is an object oriented middleware that provides an execution support hiding the technical levels of a distributed system (operating
system, processor and network). It deals with all the communications between software components building heterogeneous distributed
applications.

\paragraph{}The CORBA bus provides an object oriented client-server model for the cooperation between distributed applications.
Each application can export some of its functionnalities (services) as CORBA objects : that's the abstraction component of the model.
The interactions between the applications are then materialized as remote invocations of methods of objects : that's the cooperation part.
The client-server notion only appears when an object is used : the application actually implemented the object is seen as a server
whereas the application using it is seen as a client. Of course, one
application can be client and server at the same time.

\paragraph{}The main advantage of CORBA is to allow different programs
written in different languages, running on different hardware
architectures all around the world, to cooperate transparently with each other.

\subsection{everyday CORBA}

\subsubsection{The Interface Definition Language}
\paragraph{} The first step of a CORBA application is the IDL
definition of the service to implement. IDL stands for Interface
Definition Language. It follows C++ like syntax, and is used to define
objects and their method signatures. To keep the correspondance with
C++, it is the ``.h'' header file.

\paragraph{} Then, this IDL definition has to be translated in real
programming languages, using specific compilers. The OMG specifies for
each programming languages how IDL constructs have to be mapped to
specific languages' constructs.

\paragraph{} Once this code has been automatically generated by the
compiler, the designer just has to implement method bodies, as he
would do in the usual ``.cpp'' file in C++.

\paragraph{} The last step is to write a small server that initializes
and registers the newly created service, and then any client can
invoke it.



\section{The CORBA 2.0 specification : at the beginning was the
interface.}

\paragraph{}The main component of a CORBA 2.0 application is the
interface. An interface is an object type that is always passed by
reference when invoking methods. The interface implementation runs on
one specific machine. Other prgrams can get a reference to the
implementation of an interface, and call its methods remotely.
Interfaces support multiple inheritance.

\paragraph{}IDL also defines other standard programming language
types, that are passed as parameters by value : a new copy is created
each time a remote invocation is made. However, all these types do not
support the power of object oriented concepts.


\section{AdaBroker}

\paragraph{}AdaBroker is a full implementation of the CORBA bus, with the idl
compiler associated. Its bus is called ``broca'', and its compiler
``idlac''. AdaBroker has been developped and is maintained by the
ENST, and is released under the GNU GPL.

\section{Goal of this paper}
\paragraph{}The version 0pre1 of AdaBroker, released in april 2000,
followed the CORBA 2.0 specification. The main feature introduced by
CORBA 2.3 is the support for valuetypes, which are basically
interfaces that are passed by value. This paper presents the work done
to improve AdaBroker so that it follows the CORBA 2.3 specification. 

\paragraph{} The rest of this paper is organised as follows. The
second part presents all the new features introduced by CORBA 2.3,
with small descriptions and explanations. This part should be readable
by anybody having a small knowledge of CORBA. Part 3 presents the
implementation choices made to support the CORBA 2.3 features that were needed before
valuetypes could be implemented. Part 4 presents the architecture design chosen to
support valuetypes in AdaBroker. Part 3 and 4 are very technical since
they are meant to be a documentation for the product source code as well.

