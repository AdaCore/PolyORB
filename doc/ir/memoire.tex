\documentclass[french,a4paper,12pt]{report}
\usepackage{babel}
\usepackage{graphicx}
\usepackage[latin1]{inputenc}

\author{V. Niebel}
\title{Implémentation de l'Interface Repository \\ dans Adabroker}
\date{\today}

\begin{document}

\maketitle
\newpage
\tableofcontents

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Ce mémoire se situe dans la continuité de projets ayant
commencés au début de l'année dernière. En effet, dans
l'optique d'apporter une solution GNU au problème de l'utilisation
de CORBA en ADA, un compilateur IDL vers ADA a été écrit en C++, ainsi
qu'une interface avec OMNIORB2 en ada. Puis l'equipe de recherche
travaillant sur CORBA à l'ENST, a décidé d'ecrire un ORB
et un compilateur IDL vers ADA complètement 
en ADA afin de se libérer des problèmes d'interfaçage avec le
C++. L'ORB a été écrit par un élève en troisième année l'an
passé (Tristan Gingold), et le compilateur a été presque
entièrement réécrit cette année par toute l'équipe CORBA.


Ce compilateur et cet ORB étant écrit, il a donc été décidé de
poursuivre ce projet en ajoutant certaines fonctionnalités et services
indispensables au bon fonctionnement et à l'utilisation d'un ORB
aujourd'hui. C'est dans ce cadre que s'inscrit le projet
d'implémentation d'un interface repository (IR). Le fonctionnement et
l'utilité de ce service va être décrit plus précisemment dans le
prochain chapitre.

\chapter{Fonctionnement d'un ORB et intérêt d'un Interface
Repository}

\section{Généralité sur CORBA}
CORBA (Common Object Request Broker Architecture) est une architecture
spécifiée par un consortium industriel : l'OMG (Object Managaement
Group), afin de permettre une interopérabilité tant au niveau matériel
(PC, Sparc, ...) qu'au niveau logiciel (language de programmation,
système d'exploitation, ...). Ce consortium est composé de
constructeurs informatisques, de développeurs de logiciels et
d'utilisateurs. \\

CORBA permet donc à un utilisateur donné, de lancer une requète sur un
objet distant,situé sur une autre plate-forme et implémenté dans un
autre language, et d'en récupérer le résultat si nécessaire.

\subsection{Principe de fonctionnement}
Le fonctionnement de CORBA repose sur deux briques de base : l'ORB
(Object Request Broker), encore appelé ``bus logiciel'', et le
language IDL (Interface Definition Language).
\subsection{Le Bus Logiciel et son fonctionnement}
Ce bus n'est rien autre qu'un logiciel permettant de communiquer avec
un objet distant.  Le principe de fonctionnement est le suivant
(cf page \pageref{fig:CSModel}).\\
\begin{figure}
\label{fig:CSModel}
\begin{center}
\includegraphics[angle=270,scale=0.4]{client-server_model.ps}
\caption{Modèle Client-Server}
\end{center}
\end{figure}
Un utilisateur acquiert une référence sur un objet via une chaine
identifiante (IOR) et dispose d'une interface dans un language bien
précis afin de pouvoir invoquer statiquement une méthode sur cet
objet.\\
Le serveur dispose lui d'un squelette de l'objet (dans son language à
lui) afin de pouvoir effectivement implémenter les méthodes mises à
disposition.\\
Le bus CORBA fait le lien entre ces deux entités en 
récupérerant l'invocation de méthode du côté
client et en la transmettant du côté serveur, puis en renvoyant le
résultat (si nécessaire) du côté client. Il n'est pas nécessaire
de décrire plus en détail les mécanismes d'invocations de L'ORB dans ce
rapport, car ils ne sont pas indispensables à la compréhension du
fonctionnement et de l'utilité de l'Interface Repository.

\subsection{Les contrats IDL}
Le language IDL permet de définir des contrats, c'est à dire de décrire
l'interface des objets mis à disposition par un serveur. Ce language
est très proche du C++  et ses principales caractéristiques sont les
suivantes :
\begin{itemize}
\item il est orienté objet,
\item il dispose de l'héritage multiple.
\end{itemize}
Un exemple de contrat IDL est le suivant :
\begin{verbatim}
         interface Chicken {
              attribute string Color;
              long Lay ();
         };
\end{verbatim}
Ce contrat définit simplement un objet ``Chicken'' possedant :
\begin{itemize}
\item un attribut ``color'',
\item une méthode ``lay'' renvoyant un long.
\end{itemize}

\subsection{Les fichiers générés et l'invocation statique}
\label{static}
\subsubsection {Coté Client}
Pour pouvoir utiliser les objets spécifier en IDL de manière statique,
il faut générer les fichiers Ada correspondants. Pour ce faire, on
utilise le compilateur IDL vers Ada (idlac). Celui-ci génère les
fichiers utiles suivant :
\begin{verbatim}
chicken-helper.adb  chicken-skel.adb  chicken-stream.adb  chicken.adb 
chicken-helper.ads  chicken-skel.ads  chicken-stream.ads  chicken.ads  
\end{verbatim}
En ce qui concerne l'utilisateur, le seul fichier intéressant est
``chicken.ads'' car celui-ci contient la définition des méthodes invocables. 
Les autres fichiers ne sont utilisés que de manière interne afin
d'invoquer l'ORB et de recevoir les réponses. Les fichers ``-skel'' ne
sont pas utilisés du coté client.\\

Jetons rapidement un coup d'oeil sur ``chicken.ads'' :
\begin{verbatim}
    with CORBA;	
    pragma Elaborate_All (CORBA);
    with CORBA.Object;
    
    package Chicken is
    
       type Ref is new CORBA.Object.Ref with null record;
    
       function get_Color
         (Self : in Ref)
         return CORBA.String;
    
       procedure set_Color
         (Self : in Ref;
          To : in CORBA.String);
    
       function Lay
         (Self : in Ref)
         return CORBA.Long;
    
	[...]    
    end Chicken;
\end{verbatim}
Pour écrire un client il suffit donc d'écrire le code suivant dans
``client.adb'' pour	
changer la couleur d'un ``chicken'':
\begin{verbatim}
    [...]
    with Chicken;
    procedure Client is
       Color : CORBA.String;
       mychicken : Chicken.Ref;
    begin
       --  transforms the Ada string into CORBA.String
       IOR := CORBA.To_CORBA_String (Ada.Command_Line.Argument (1));

       --  getting the CORBA.Object
       CORBA.ORB.String_To_Object (IOR, mychicken);

       Chicken.Set_Color (mychicken, Color);
    end Client;
\end{verbatim}
Les deux premières opérations de cette procédure permettent de
récupérer une référence sur l'objet chicken à partir d'une chaine
identifiante passée en paramètre (IOR), et la dernière permet d'invoquer une
méthode de l'objet récupérer.

\subsubsection {Coté Serveur}
En ce qui concerne le serveur, il faut générer des fichier nécessaires
à l'implémentations. Pour ce faire, on utilise toujours le compilateur
IDL vers Ada mais en rajoutant l'option -i. Les fichiers générés sont
alors les suivants:
\begin{verbatim}
chicken-helper.adb  chicken-skel.adb  chicken-stream.adb  chicken.adb 
chicken-helper.ads  chicken-skel.ads  chicken-stream.ads  chicken.ads  
chicken-impl.ads 
chicken-impl.adb
\end{verbatim}
Dans le cas du serveur, les seuls fichiers vraiment intéressants sont
les fichiers ``chicken-impl.adb'' et ``chicken-impl.ads''. Ce sont les
fichiers qui sont déstinés à contenir l'implémentation des méthodes.\\
Le fichier ``chicken-impl.ads'' est le suivant :
\begin{verbatim}
package Chicken.Impl is

   type Object is
     new PortableServer.Servant_Base with private;

   type Object_Ptr is access all Object'Class;

   function get_Color
     (Self : access Object)
     return CORBA.String;

   procedure set_Color
     (Self : access Object;
      To : in CORBA.String);

   function Lay
     (Self : access Object)
     return CORBA.Long;
[...]
end Chicken.Impl;
\end{verbatim}
Le fichier adb correspondant contient ces procédures avec un corps vide.
Il suffit donc de remplir le corps de ces
fonctions pour disposer d'un objet implémenter.\\
La dernière étape côté serveur est d'activer l'objet et de créer sa
chaine identifiante (IOR). Cela est fait par le serveur suivant :
\begin{verbatim}
with Chicken.Impl;
[...]
procedure Server is
   Ref : CORBA.Object.Ref;
begin
   Initiate_Servant (new Chicken.Impl.Object, Ref);
   Ada.Text_IO.Put_Line
     ("'" & CORBA.To_Standard_String (CORBA.Object.Object_To_String (Ref)) &
      "'");
   Initiate_Server;
end Server;
\end{verbatim}
La ligne qui s'affichera sera l'identifiant de l'objet, qu'il faudra
fournir au client afin de permettre une invocation.

\subsubsection{Résumé}
En résumé, afin d'utiliser un objet CORBA il faut (cf figure page \pageref{fig:ResModel}) :
\begin{itemize}
\item Définir un contrat IDL puis le compiler vers le language désiré.
\item Implémenter les fichiers ``-impl'' et activer l'objet.
\item Récupérer la chaine identifiante de l'objet activé et écrire un client.
\end{itemize}
\begin{figure}	
\label{fig:ResModel}
\begin{center}
\includegraphics[scale=0.4]{CORBA.ps}
\caption{fonctionnement de CORBA}
\end{center}
\end{figure}

\section{L'invocation dynamique}
En fait, deux possibilités s'offrent à un utilisateur d'un ORB
désirant programmer
un client. L'objet à utiliser peut être accéder de manière
statique (\ref{static})  ou dynamique.
Je viens de décrire la façon d'accéder un objet de manière statique,
je vais à présent décrire plus rapidement une requète dynamique, car la	
compréhension de ce fonctionnement est indispensable afin de bien saisir
la nécessité d'un Interface Repository.	

\subsubsection{Invocation Dynamique}

Cette méthode d'invocation n'affecte que le côté client.\\


Lors d'une invocation dynamique, le client n'a pas forcément accès au
contrat IDL détaillé de l'objet qu'il désire utiliser. Ainsi les fichiers
automatiquement généré lors de la compilation du contrat, permettant
une invocation transparente de l'ORB, ne sont plus à disposition du
client. \\	


Il est alors nécessaire de construire entièrement à la main les
requètes à l'ORB afin qu'il puisse les transmettre à l'objet
voulu. Ces requètes faisant toutes appel à une même procédure de l'ORB, il
est nécessaires de construire des appels à l'aide d'objets pouvant
contenir n'importe quelle valeur. Ces objets sont appelés des {\it any}
et les objets permettant de les décrire sont appelés des {\it typecode}.\\


Un client dynamique peut donc procéder de la façon suivante :
\begin{itemize}
\item Récupération d'une référence sur l'objet à utiliser, soit par le service
de nommage, soit par IOR.
\item Récupération de la description de cet objet (méthodes, types défini...) :
Ceci se fait à l'aide d'une méthode {\it get\_interface}, permettant de récupérer
une description complète de l'objet, stockée dans un Interface
Repository (IR). En cas 
d'absence de l'IR, la connaissance au préalable des signatures et noms de méthodes 
sont indispensables à une invocation de méthode.
\item Fabrication d'une requète en instanciant un objet générique ({\it Request)}
et en y ajoutant les paramètres à l'aide des valeurs génériques
autodescriptifs	 ({\it any})
créer auparavant.
\end{itemize}


Pour plus de détails sur l'invocation dynamique, vous pouvez consulter
la documentation sur ce sujet fourni avec AdaBroker et écrite par
Sébastien Ponce.

\section{L'interface repository}

\subsection{Intérêt}

L'IR se place donc principalement dans le contexte d'une invocation dynamique,
durant laquelle le client ne connait pas a priori les méthodes, les types,
les exceptions ou les attributs dont ils
disposent concernant un certain objet.


Le serveur, au moment d'enregistrer cet objet auprès de l'ORB, l'enregistre 
également auprès de l'IR de l'ORB du client. Cet IR étant accessible par tout 
client de cet ORB, ceux-ci peuvent parfaitement connaitre la composition d'un
objet et donc l'utiliser de manière dynamique sans problème en accèdant
dynamiquement  l'IR et en créant les requètes en fonction du résultat.


Cette méthode de procéder permet ainsi d'utiliser des objets dynamiquement
sans rien en connaitre a priori. L'IR peut être vu comme une base de données
des spécifications des objets disponibles dynamiquements. En fait, ce service
permet de créer un arbre dont les noeuds représentent un type IDL : interface, type,
module, exceptions, operation... Cet arbre est organisé sémantiquement  
comme l'IDL avec des noeuds {\it container} (repository, module, interface, struct,
union, exception, operation...) pouvant contenir des noeuds du type {\it contained}. 
On observe le même type de restrictions qu'en IDL :
 "une opération doit se situer dans une interface" ...
Pour plus de détail, vous pouvez vous référer à la description du language IDL
et au chapitre sur les Interface Repository écrits par l'OMG. 

\subsection{Caractéristiques}

L'IR est donc un service se l'ORB permettant de stocker des données au sujet d'objets
accessibles à partir de cet ORB. Sa description en IDL, ainsi que son fonctionnement 
sera plus amplement détailler dans la partie Implémentation. 


On peut cependant déjà préciser que l'IR est un child-package du package Corba, et 
de ce fait est un service extrèmement lié à l'ORB. Il contient toutes les fonctions
nécessaires à la création de nouveau noeuds dans son arbre de stockage d'objets,
ainsi que toutes les fonctions nécessaires à son parcours et à une recherche
précise. 


Chaque IR doit possèder un mécanisme de stockage persistent. En effet, lors  de l'arrêt
de ce service, l'arbre doit être stocké de manière persistante
en utilisant le moyen de son choix, sachant qu'au redémarrage, il devra être
possible de tout reconstituer. 


Cet IR possède un autre avantage. Chaque objet ayant son propre identifiant, 
dépendant de son numéro de version, on peut accèder à différentes versions
d'un même objet et donc de ne pas perdre de fonctionnalités en cas de sortie
d'une nouvelle version (peut être incompatible avec d'anciens clients).   
      

La norme prévoit également un mécanisme de droit sur les IR. En effet, 
un ORB peut possèder plusieurs IR, et ainsi on peut imaginer un système
de droit en permettant à certains clients d'accèder à certains IR 
possèdant la desritpion de certaines méthodes critiques, et en refusant
l'accès à cet IR à d'autres clients.


\chapter{Caractéristiques des IR existants}

Très peu d'ORBs offrent aujourd'hui la possibilité d'utiliser le
language Ada. En fait il n'existe qu'un seul logiciel mais il est
payant. De ce fait, je n'ai pas eu accès à une implémentation Ada de
l'IR. \\


Je n'ai pu tirer que très peu d'information des autres
implémentations. Ceci s'expiquant par le fait que le mapping Ada est
très spécific et pose de nombreux problèmes afin de se conformer aux
normes. Nous en parlerons plus longuement dans le prochain chapître,
dans lequel je parlerai plus spécifiquement de l'implémentation et des
problèmes rencontrés.


\section{Implémentation}

Les IR existant ont globalement été implémenté de la manière suivante.
Les programmeurs ont récupéré la spécification en pseudo-IDL de l'IR faite par l'OMG et
l'ont adapté à leurs besoins et désirs en rajoutant certaines fonctionnalités.


Après cette phase de spécifications, ils ont passé cette spécification au compilateur
IDL adéquat, celui-ci générant les skelettes et les fichiers à impléménter. En
effet, l'IR fonctionne comme un serveur classique dans tous les cas que j'ai examiné.

\section{Choix du stockage et de la population}
J'ai pu installer deux ORBs  (ORBit, Mico) possèdant un IR sur mon PC. 
Les deux avaient opté
pour un stockage sous forme d'un fichier IDL lors de l'arrêt du service.
Ce format est en effet bien adapté car c'est un format lisible et permettant
un stockage complet notamment à l'aide des mécanismes de pragmas.
De plus les règle de nommage et de gestion des scopes est pratiquement
la même pour l'IR que pour l'IDL.



Afin de peupler l'IR, ces deux ORBs avaient écrit un petit programme de population
prenant en paramètre un fichier IDL (et éventuellement l'IOR de l'IR à peupler). 
Ils proposaient également une population directe par client, en utilisant les méthodes
définies par la norme. 

\section{Accession à l'IR}

Pour qu'un client accède à l'IR, il doit récupérer son objet à travers l'ORB. 
Pour ce faire, deux méthodes ont été prévue dans e que j'ai vu:
\begin{itemize}
\item Mico et ORBacus proposait d'accèder à une référence sur l'IR grâce à
la méthode {\it Resolve\_Initial\_Reference(Interface\_Repository)}. A partir de
cette référence, on pouvait ensuite y faire des recherches.
\item ORBit décrivait également cette méthode dans son manuel théorique, mais précisait
que pour son ORB, il fallait préciser l'IOR de l'IR en paramètre du client
qui voulait l'utiliser. Cette méthode était également disponible chez Mico
pour accèder à un IR autre que celui par "défaut".
\end{itemize}


\chapter{Architecture et Implémentation de l'IR}

\section{Architecture}
Bien que l'implémentation de ce service n'a été que commencée, et que
la plupart des fonctionnalités sont encore absentes (accession par \linebreak
{\it Resolve\_Initial\_Reference}, peuplement, stockage persistent),
des choix semblent s'imposer pour les futurs programmeurs.

\subsection{Choix de l'accession à la l'IR}

Ce qui me semble à priori le plus logique est de faire coexister les deux méthodes 
d'accession:
\begin{itemize}
\item La méthode {\it Resolve\_Initial\_Reference} permettra de récupérer la 
référence de l'IR par défaut.
\item L'accession d'un IR par IOR passé en paramètre à un client
afin de pouvoir disposer de plusieurs IR, ce qui semble logique car ce n'est
qu'en fait qu'un objet quelconque (serveur) enregistré auprès d'un ORB.
\end{itemize}

\subsection{Choix du peuplement}

Le peuplement sera le suivant : en modifiant le compilateur existant, il sera 
possible de lui spécifier par une option que le fichier IDL passé en paramètre
est déstiné à peupler l'IR. En fait le compilateur génèrera un client dont la simple
éxecution peuplera l'IR spécifier lors de la compilation.

\subsection{Choix du stockage persistent}

Le stockage le plus intéressant, lors d'un arrêt du service, serait un fichier IDL. En effet ce
fichier permettrait une lecture facile de l'IR en cas d'arrêt du
service ou de ``dump'' intermédiaire.\\


De plus il permettrait une repopulation facile en utilisant la
population classique par l'intermédiaire du compilateur modifié.


\section{Compilation du contrat}
Le contrat IDL de l'IR est en fait du pseudo-IDL. Cela signifie qu'il
n'est pas voué à être directement utilisé par un compilateur
IDL. Cependant, moyennant quelques petites modifications, {\it idlac}
devait pouvoir compiler ce contrat. De plus, l'idée qui
consistait à vouloir tout écrire à la main était un peu absurde car le
compilateur a tout de même généré près de 50000 lignes de codes pour
ce service, un gain de temps considérable, surtout que le code généré
compilait!\\


L'implémentation de l'IR à donc classiquement consister dans 
un premier temps à compiler la spécification de l'OMG, puis dans un second temps
à implémenter les fichiers {\it impl} associés.


\subsection{Problèmes de compilation de la spécification}
Un problème assez important fut cependant de  définir la spécification
exacte de l'IR
que nous allions retenir pour l'implémentation. En effet, l'IR étant
défini comme service par l'OMG,donc son interface complète était fournie.\\


De gros problèmes se posaient cependant quand il s'agissait
d'appliquer le mapping Ada à ce contrat. Il a donc fallu assez
largement la modifier. Les problèmes étaient les suivants :

\subsubsection{Problème de dépendance sur fils}
Supposons le contrat suivant:
\begin{verbatim}
module test {
   interface Chicken{};
   struct soupe {
      Chicken Ingredient;
   };
};
\end{verbatim}
En appliquant le mapping Ada, la structure {\it soupe} est définie dans le
fichier test.ads et le type {\it Chicken.Ref} est défini dans le
fichier test-chicken.ads. Hors ce dernier type est utilisé dans la
structure {\it soupe} ainsi il faudrait inclure ({\it with})
test-chicken dans test, ce qui est totalement interdit en Ada.\\


Conclusion, il a fallu déclaré des ``forward interface'' dans ces cas,
afin de ne plus avoir de dépendances sur fils :
\begin{verbatim}
module test {
   interface Chicken;
   struct soupe {
       Chicken Ingredient;
   };
   interface Chicken{};
};
\end{verbatim}

\subsubsection{Problème de Forward dans CORBA}
Supposons le contrat suivant :
\begin{verbatim}
module CORBA {
   interface Chicken;
   struct soupe {
       Chicken Ingredient;
   };
   interface Chicken{};
};
\end{verbatim}
Le problème précédent nous a donc amené à celui-ci. La création d'un
forward se traduit dans CORBA par l'instanciation d'un package générique
nommé {\it CORBA.Forward}. Hors comme le forward se situait dans le
package CORBA, cela créait à nouveau une dépendance sur fils.\\


Une façon hâtive de règler ce problème était de définir, pour le module CORBA, cette
instanciation de Forward dans un fils de CORBA. Mais l'utilisation du
forward dans la stucture {\it soupe} situé dans CORBA rétablissait la dépendance
sur Fils.\\


Ce problème semble être insoluble sans modification de la norme, c'est
pourquoi nous avons soumis une modification à l'OMG, préconisant de
créer l'Interface Repository dans un fils de CORBA appelé {\it
Repository\_Root}, tout en laissant certains types nécessaires à
d'autres services, et non problèmatiques, dans le module CORBA.\\


Aucune décision n'a semble-t-il été prise à l'heure où j'écris ce
rapport. 

\subsection{Les Typecodes}
Après avoir modifier la spécification de l'IR comme indiquer
ci-dessus, j'ai encore du la modifier un peu car elle incluait les
TypeCode, qui étaient alors implémenté par Sebastien Ponce (cf sa
documentation, ou la documentation de l'OMG). \\

Cette modification a juste consister en la création d'une interface
fictive dans CORBA :
\begin{verbatim}
module CORBA {
   interface TypeCode{};
};
\end{verbatim}
Ensuite, un scripte shell basé sur des ``sed'' était lancer pour
modifier les fichier générés par idlac et pour rétablir les bonnes
dépendances. Ce script se chargeait également d'effacer les fichiers
générés devenus superflus.\\


Ce script est disponible en annexe (annexe \ref{script} page \pageref{script}).
La version définitive de ma spécification de l'Interface Repository est en annexe
(annexe \ref{specIR} page \pageref{specIR}).


\subsection{Les modifications du compilateur ({\it pragma})}
Une dernière tâche avant de pouvoir compiler et généré du code correct
était donc de rajouter la gestion des {\it pragma} (commande spécific
de l'IDL permettant de fixer certains paramètres des objets) spécifics
à l'Interface Repository.\\

Il existe trois sortent de {\it pragma} :
\begin{itemize}
\item le {\it Pragma Id} : il permet de fixer le RepositoryId
(identifiant unique au sein de l'IR) d'un objet donné. Un exemple
d'utilisation
\begin{verbatim}
       interface A {};
       #pragma ID A ``IDL:A:1.1''  	 
\end{verbatim}
\item le {\it Pragma Prefix} : il permet de fixer le prefix des
RepositoryId  des objet suivant le {\it pragma} et
situés dans ce scope. Un exemple
d'utilisation
\begin{verbatim}
       #pragma prefix TOTO  	 
       interface A {};
\end{verbatim}
Cela donnerait le RepositoryId pour A suivant : ``IDL:TOTO/A:1.0''
\item le {\it Pragma Version} : il permet de fixer la version du
RepositoryId  d'un objet spécifié. Un exemple
d'utilisation
\begin{verbatim}
       interface A {};
       #pragma version A ``9.9''  	 
\end{verbatim}
Cela donnerait le RepositoryId pour A suivant : ``IDL:A:9.9''
\end{itemize}
Il est à noter qu'on ne peut pas fixer un {\it pragma} Id et un {\it pragma}
Version pour un même objet. \\


\section{Implémentation de l'IR}
La compilation de l'interface de l'IR étant réalisée, j'ai pu
m'attaquer à l'implémentation du service proprement dit.
\subsection{Hiérarchie des Classes}
L'Interface Repository est composé de 26 classes différentes, dont 21
instanciables représentant tous les types d'objets IDL. Le nom d'une
classe est en fait le nom de son objet IDL suivi de ``Def''
(InterfaceDef, ConstantDef, ValueDef ...). Ces objets
permettent donc de stocker toutes les définitions IDL, avec des règles
de structure et de navigations très proche de l'IDL (cf figure page
\ref{nav}).


\begin{figure}[h]
\label{nav}
\begin{center}
\includegraphics[angle=270,scale=0.65]{struct.ps}
\caption{Graphe de structure et de navigation de l'IR}
\end{center}
\end{figure}

Toutes les classes de l'interface repository descendent de la classe
IRObject, celle-ci possèdant un attribut {\it def\_kind} (type du
noeud), et une méthode {\it destroy} afin de détruire le noeud.\\


Ensuite, au deuxième niveau viennent les classes :
\begin{itemize}
\item {\it \bf Contained} : parent des noeuds pouvant être contenus
(contient le nom, l'ID, la version ...).
\item {\it \bf Container} : prent des noeuds pouvant contenir (contient
les méthodes de création de noeuds ...).
\item {\it \bf IDLType} : parent des noeuds pouvant être considéré comme
un type en IDL.
\end{itemize}


Il y a encore une classe ``parent'' : la classe {\it
TypedefDef}. Celle-ci contient tous les noeuds pouvant être définis
par une déclaration de type en IDL (cf figure page
\ref{nav})\\


Finalement les noeuds ``feuilles'' représentent les objets instancier
dans l'IR, et traduisent l'objet IDL correspondant. Le graphe
d'héritage complet de l'IR est
représenté page \ref{heritage}.

\begin{figure}
\label{heritage}
\begin{center}
\includegraphics[angle=0,scale=0.9]{heritage.ps}
\caption{Graphe d'héritage de l'IR}
\end{center}
\end{figure}

\subsection{Gestion de l'héritage multiple}
Comme vous pouvez le constater sur la figure page \ref{heritage},
l'héritage n'est malheureusement pas simple, alors que le language
ADA95 ne supporte que de l'héritage simple. Il a donc fallu imaginer
un mécanisme permettant la simulation de cet héritage multiple.

\subsubsection{Les champs supplémentaires}
Afin de bien comprendre le mécanisme utilisé, nous allons prendre
l'exemple de l'objet {\it InterfaceDef} dont la spécification en IDL
s'écrit :
\begin{verbatim}
    interface InterfaceDef : Container, Contained, IDLType {
    [...]  };    
\end{verbatim}
Elle hérite donc des trois classes de base, et le mapping Ada veut
qu'elle hérite directement de {\it Container}. Ainsi les méthodes et
attributs de {\it Container} sont hérité de manière classique dans {\it
InterfaceDef}.\\
Le mapping veut que les autres attributs et méthodes de {\it Contained} et de {\it
IDLType} soient tout simplement recopier. Mais pour une question de
factorisation de code, et surtout de ``cast'', la solution afin
d'émuler l'héritage multiple fut de rajouter des champs privés {\it
Contained\_View} et {\it IDLType\_View} à
l'objet {\it InterfaceDef}, permettant de décrire une Interface en
tant que {\it Contained} ou {\it IDLType} :
\begin{verbatim}
package CORBA.Repository_Root.InterfaceDef.Impl is
   type Object is
     new CORBA.Repository_Root.Container.Impl.Object with private;
   [...]
   function Get_Contained_View (Self : access Object)
     return CORBA.Repository_Root.Contained.Impl.Object_Ptr;

   function Get_IDLType_View (Self : access Object)
     return CORBA.Repository_Root.IDLType.Impl.Object_Ptr;
   [...]
private
   type Object is
     new CORBA.Repository_Root.Container.Impl.Object with record
        Contained_View : CORBA.Repository_Root.Contained.Impl.Object_Ptr;
        IDLType_View : CORBA.Repository_Root.IDLType.Impl.Object_Ptr;
        [...]
   end record;
end CORBA.Repository_Root.InterfaceDef.Impl;
\end{verbatim}
Ces champs sont uniquement accessible en lecture grâce aux méthodes
{\it get\_...} ci\_dessus.

A partir de cette architecture, une méthode de {\it Contained},
recopiée dans {\it InterfaceDef} sera un simple appel de la véritable
procédure sur le champ {\it Contained\_View} :
\begin{verbatim}
   function get_name
     (Self : access Object)
     return CORBA.Identifier
   is
   begin
      return Contained.Impl.Get_Name (Self.Contained_View);
   end get_name;
\end{verbatim}

Cette solution n'était cependant pas complète, car on pouvait
maintenant ``caster'' un objet vers un parent, mais le sens inverse
n'était pas encore supporté. C'est pourquoi, chaque objet devait
contenir un pointeur vers son type le plus précis. Ceci a été réalisé
en ajoutant un champs privé {\it Real\_Object} à la classe de base de
l'IR : {\it IRObject}.
\begin{verbatim}
package CORBA.Repository_Root.IRObject.Impl is
   type Object is new PortableServer.Servant_Base with private;
   type Object_Ptr is access all Object'Class;
   [...]
   function Get_Real_Object (Self : access Object)
     return Object_Ptr;
   [...]
private
   type Object is
     new PortableServer.Servant_Base with record
        Real_Object : Object_Ptr;
        [...]
     end record;
end CORBA.Repository_Root.IRObject.Impl;
\end{verbatim}
Ce champ était accessible uniquement en lecture par la fonction {\it
Get\_Real\_Object}.
\subsubsection{Les fonctions To\_$<$parent$>$}
Cette structure mise en place, il restait à écrire quelques fonctions
de ``cast'' utiles lors de l'écriture de certaines fonctions. Ces
fonctions prennent toutes un pointeur vers un {\it IROBject'Class},
qui doit {\bf obligatoirement} être l'objet le plus précis (le {\it
Real\_Object}).\\


Trois procédures ont donc été écrites :
\begin{itemize}
\item To\_Contained : définie dans  le package Contained.Impl.
\item To\_Container : définie dans  le package Container.Impl.
\item To\_IDLType : définie dans  le package IDLType.Impl.
\end{itemize}
Seuls ces classes participent à l'héritage multiple.\\

Leur implémentation était relativement simple. On parcourait le type
réél de l'objet (contenu dans IRObject), puis on récupérait les Views
correspondantes. \\

Il existe deux types de To\_$<$parent$>$ :
\begin{verbatim}
   procedure To_Contained
     (Self : CORBA.Repository_Root.IRObject.Impl.Object_Ptr;
      Success : out Boolean;
      Result : out Object_Ptr);

   function To_Contained
     (Self : CORBA.Repository_Root.IRObject.Impl.Object_Ptr)
     return Object_Ptr;
\end{verbatim}
La première procédure permet de prendre n'importe quel type de classes
feuilles et renvoie un booléen si le cast a réussi (true). La fonction
lance elle une exception si le type passé n'est pas un descendant de
{\it Contained}. 

\subsection{Les fonctions To\_Object, To\_Forward}
Un autre problème de l'implémentation fut la transformation des objets
en forward référence et vice-versa (Rq: j'utilise directement les
forward, car les classes sur lesquelles j'utilisaient ces fonctions, étaient
presque toujours renvoyées sous forme de forward\_ref, et non de
ref).\\

Il existe donc deux fonctions, inverse l'une de l'autre, qui
transforment des {\it Object\_ptr} en {\it Forward.Ref} et inversement :
\begin{verbatim}
package CORBA.Repository_Root.Contained.Impl is
   [...]
   function To_Object (Fw_Ref : Contained_Forward.Ref)
                       return Object_Ptr;
   function To_Forward (Obj : Object_Ptr)
                        return Contained_Forward.Ref;
   [...]
end CORBA.Repository_Root.Contained.Impl;
\end{verbatim}
Dans le cas des classes ``feuilles'' de notre graphe, ces fonctions
étaient relativement simple à écrire. Elles se résumaient à
l'utilisation de {\it Broca.Server\_Tools.Reference\_To\_Servant} et de
{\it Broca.Server\_Tools.Initiate\_Servant} (équivalent à {\it
Broca.Server\_Tools.Servant\_To\_Reference}) : 
\begin{verbatim}
   function To_Object (Fw_Ref : InterfaceDef_Forward.Ref)
                       return Object_Ptr is
      Result : Portableserver.Servant;
   begin
      Broca.Server_Tools.Reference_To_Servant
        (InterfaceDef.Convert_Forward.To_Ref (Fw_Ref),
         Result);
      return Object_Ptr (Result);
   end To_Object;

   function To_Forward (Obj : Object_Ptr)
                        return InterfaceDef_Forward.Ref is
      Ref : InterfaceDef.Ref;
   begin
      Broca.Server_Tools.Initiate_Servant (PortableServer.Servant (Obj),
                                           Ref);
      return InterfaceDef.Convert_Forward.To_Forward (Ref);
   end To_Forward;
\end{verbatim}


Malheureusement dans le cas d'un  {\it Container}, d'un {\it
Contained} ou d'un {\it IDLType}, il fallait prendre plus de
précaution car {\bf l'objet lié à une référence doit être l'objet le
plus précis}, et non une vue de l'objet dans un de ses ancêtres. Ainsi
pour {\it Contained} les procédures s'écrivaient :

\begin{verbatim}
   function To_Object (Fw_Ref : Contained_Forward.Ref)
                       return Object_Ptr is
      Result : Portableserver.Servant;
      The_Ref : Contained.Ref;
   begin
      The_Ref := Contained.Convert_Forward.To_Ref (Fw_Ref);
      Broca.Server_Tools.Reference_To_Servant (The_Ref,
                                               Result);
      return To_Contained (IROBject.Impl.Object_Ptr (Result));
   end To_Object;

   function To_Forward (Obj : Object_Ptr)
                        return Contained_Forward.Ref is
      Result : Contained_Forward.Ref;
   begin
      case Get_Def_Kind (Obj) is
      [...]
         when
           Dk_Interface  =>
            declare
               The_Ref : InterfaceDef.Ref;
            begin
               Broca.Server_Tools.Initiate_Servant (PortableServer.Servant
                                                    (Get_Real_Object (Obj)),
                                                    The_Ref);
               return Contained.Convert_Forward.To_Forward
                 (Contained.Helper.To_Ref (The_Ref));
            end;
      [...]
      end case;
   end To_Forward;
\end{verbatim}


La transformation d'objet en ref (non forward) et vice-versa se posait très rarement
et était très simple (une ligne), elle a donc résulté en une implémentation au cas
par cas.

\subsection{Implémentation des attributs}
\subsubsection{Implémentation classique}
Les attributs IDL furent dans la plupart des cas implémenter sous
forme de champ privés, accessible par méthode {\it get} et {\it
set}.
\begin{verbatim}
package CORBA.Repository_Root.Contained.Impl is
   [...]
   function get_id (Self : access Object) return CORBA.RepositoryId;

   procedure set_id (Self : access Object; To : in CORBA.RepositoryId);
   [...]
private
   type Object is
     new CORBA.Repository_Root.IRObject.Impl.Object with record
        Id : CORBA.RepositoryId;
        Name : CORBA.Identifier;
        Version : CORBA.Repository_Root.VersionSpec;
        Defined_In : CORBA.Repository_Root.Container_Forward.Ref;
     end record;
end CORBA.Repository_Root.Contained.Impl;
\end{verbatim}

\subsubsection{Cas des redondances}
Cependant, certaines informations étaient redondantes, et donc
les champs étaient calculé dynamiquement.\\
Par exemple l'attribut {\it Type} de l'objet {\it IDLType} n'est en
fait qu'un {\it TypeCode} décrivant le type associé. Cependant, ce
{\it TypeCode} étant spécifique à chaque type d'objet, et pouvant être
modifié à tout instant (il est cependant ``readonly''!), il n'a pas
été implémenté sous forme de champs privé, mais les méthodes {\it
Get\_Type} ont été surchargées dans toutes les classes héritants de
{\it IDLType}. L'information sur le nom, la version ... de l'objet n'a
donc pas été dupliquée.\\
De même la norme indique par exemple que l'attribut {\it type} de
l'objet {\it ConstantDef} doit être identique au champ {\it type} de
son attribut {\it type\_def}. Ce type de redondance est assez fréquent
et a été implémenté pour éviter la duplication des informations.


\subsubsection{Problème des TC\_VOID dans les structs, unions et exceptions}
Dans cette  logique de programmation, une partie de la spec n'a pu
être implémentée. \\
En effet, dans la spécification de l'IR pour les
{\it StructDef} (p10-24, pargraphe 1), il est précisé que lorsque le
champ {\it members} est
affecté, tous les membres de cette liste doivent avoir leur champs
{\it type} placé à TC\_VOID (le typecode vide). De plus cette même
norme spécifie (p 10-55, 1er paragraphe) que le champ {\it type\_def}
de ces membres doit également être nulle! En conséquence, il n'y
aurait plus de moyen de récupérer le type d'un membre, si ce n'est en
parcourant le TypeCode de la {\it StructDef} qui est en théorie
``ReadOnly'',et qui en
pratique peut être modifié en changeant par exemple le nom de
l'objet.\\
L'implémentation s'est donc résumé à gardé le champ {\it type} des
membres (les fonctions initialize\_members ne font donc rien), et à
calculer dynamiquement le {\it TypeCode} de la {\it
StructDef} à partir de ces champs.

\subsection{La liste de stockage}
\subsubsection{Définition}
Il a fallu choisir une méthode de stockage pour les objets héritants
de {\it Container}. Après de nombreuses hésitations, nous avons
finalement décidé que les {\it sequence} défini dans {\it
CORBA.Sequence.Unbounded} correspondait assez à mes attentes, et
qu'elles avaient l'avantage d'être clairement spécifiées, contrôlées et déjà
largement utilisées.\\
La définition du package {\it Contained\_Seq} est donc le suivant :
\begin{verbatim}
package CORBA.Repository_Root.Contained.Impl is
   type Object is
     new CORBA.Repository_Root.IRObject.Impl.Object with private;
   type Object_Ptr is access all Object'Class;
   [...]	
   package Contained_Seq is new Sequences.Unbounded (Object_Ptr);
   [...]
end CORBA.Repository_Root.Contained.Impl;
\end{verbatim}
Le champs decrivant le corps d'un {\it Container} était donc le champs
{\it contents} défini ci-dessous :
\begin{verbatim}
package CORBA.Repository_Root.Container.Impl is
   [...]
private
   type Object is
     new CORBA.Repository_Root.IRObject.Impl.Object with record
        Contents : CORBA.Repository_Root.Contained.Impl.Contained_Seq.Sequence;
   end record;
end CORBA.Repository_Root.Container.Impl;
\end{verbatim}

\subsubsection{Fonctions de Recherche}
Les fonctions de recherche devaient initialement être dérivée d'un
nouveau package ajouté à {\it sequence}. Cependant, la complexité des
recherches m'a fait opté pour une méthode assez efficace quand même.\\

En fait chaque méthode de recherche d'un objet {\it Container} ou d'un
objet {\it Repository} avait son pendant dans le package {\it
Contained} où le contenu de l'objet était réellement parcouru. Cette
décomposition a permis de faire des recherches bien découpée et
récursives.\\


Par exemple, la fonction {\it Contents} contenu dans {\it Container}
appelle d'abord celle de {\it Contained} sur le contenu actuel, puis
se rappelle récursivement si nécessaire :
\begin{verbatim}
   function contents
     (Self : access Object;
      limit_type : in CORBA.Repository_Root.DefinitionKind;
      exclude_inherited : in CORBA.Boolean)
      return CORBA.Repository_Root.ContainedSeq
   is
   [...]
   begin
      --  Get the direct contained
      Result := Contained.Impl.Contents (Self.Contents,
                                         Limit_Type);
      [...]
   end;
\end{verbatim}

\subsection{La création d'un nouveau noeud}
\subsubsection{Les fonctions {\it create} et {\it init}}
Un nouveau noeud est créer simplement en invoquant les méthodes de
création d'objet dans {\it Container}. Ces méthodes sont toujours
implémentées de la même façon:
\begin{itemize}
\item Vérifications de la structure de l'IR,de la gestion de nom et de
l'unicité de l'Id en cas d'insertion de ce noeud (intégrité du
Repository)
\item Création et initialisation des champs de l'objet en invoquant
les méthodes {\it init} définies dans chaques classes. Ces méthodes
s'invoquent hiérarchiquement afin d'initialiser tous les champs privés
ainsi que les Views dans le cas d'un héritage multiple.
\item Ajout de ce noeud (ou de sa view en tant que {\it Contained})
au contenu du {\it Container} 
\item Enregistrement de ce nouvel objet auprès d'un POA (par
l'intermédiaire du {\it To\_Forward}).
\end{itemize}


Voici un exemple de ces quatres dans la création d'un {\it StructDef}:
\begin{verbatim}
   function create_struct
     ([...])
      return CORBA.Repository_Root.StructDef_Forward.Ref
   is [...] begin
      if Check_Structure (Self, Dk_Struct) and        -- ETAPE 1 --
        Check_Id (Self, Id) and
        Check_Name (Self, Name) then

         StructDef.Impl.Init ([...]);                 -- ETAPE 2 --

         Append_To_Contents                           -- ETAPE 3 --
           (Self,
            Contained.Impl.To_Contained
             (IRObject.Impl.Object_Ptr (Obj)));
      end if;

      return StructDef.Impl.To_Forward (Obj);         -- ETAPE 4 --
   end create_struct;
\end{verbatim}

\subsubsection{Les exceptions levées} (page 10-10)
Un certains nombre d'exceptions peuvent être levée par un utilisteur
lors de la création d'un objet (ou du changement de nom, ou d'Id). En
effet les fonctions appelées {\it Check\_Structure}, {\it Check\_Name} et {\it
Check\_Id},contenue dans {\it Container}, ont pour rôle de vérifier
l'intégrité du Repository dans le cas d'une modification ou d'une
création d'objet.  Elles peuvent lever des exceptions dans le cas
contraire. Le code des exceptions est le suivant:

\begin{center}
\begin{tabular}{|c|c|l|}
\hline
{\bf Exception} & {\bf Minor Code} & {\bf Explanation} \\
\hline
BAD\_PARAM & 2 & Id est déjà dans l'IR \\
\cline{2-3}
& 3 & Le nom est déjà utilisé dans le contexte \\
\cline{2-3}
& 4 & La cible n'est pas un container valide \\
\cline{2-3}
& 5 & Le nom est déjà utilisé dans le contexte \\
&& hérité \\
\hline
BAD\_INV\_ORDER & 1 & Des dépendances existe dans l'IR\\
&& empèchant toute destruction \\
\cline{2-3}
& 2 & Tentative de destruction d'un objet \\
&& indestructible de l'IR \\
\hline
\end{tabular}
\end{center}

La destruction des objets n'étant pas encore implémentées, les deux
dernières exceptions ne sont pas levées. 

\section{Un exemple de création de nodes}


\section{Bilan de l'implémentation, TODO}
De même, il n'y a de
vérification de nom que sur le contexte immédiat, et non hérité (à
améliorer ...)


\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}

\appendix
\chapter{Spécification de l'IR}
\label{specIR}
\begin{verbatim}
// File: CORBA_InterfaceRepository.idl
// CORBA 2.3, Chapter 10

#pragma prefix "omg.org"
module CORBA {
  typedef string Identifier;
  typedef string ScopedName;
  typedef string RepositoryId;
  interface TypeCode {};

  module Repository_Root {
    enum DefinitionKind {
#       pragma version DefinitionKind 2.3
        dk_none,        dk_all,
        dk_Attribute,   dk_Constant,    dk_Exception,   dk_Interface,
        dk_Module,      dk_Operation,   dk_Typedef,
        dk_Alias,       dk_Struct,      dk_Union,       dk_Enum,
        dk_Primitive,   dk_String,      dk_Sequence,    dk_Array,
        dk_Repository,
        dk_Wstring,     dk_Fixed,
        dk_Value,       dk_ValueBox,    dk_ValueMember,
        dk_Native
    };

    interface IRObject {
#       pragma version IRObject 2.3
        // read interface
        readonly attribute  DefinitionKind  def_kind;
        // write interface
        void                destroy ();
    };
    
    typedef string VersionSpec;

    interface Repository;
    interface Container;
    interface Contained;
    
    typedef sequence <Contained> ContainedSeq;
    
    interface Contained : IRObject {
#       pragma version Contained 2.3

        // read/write interface
        attribute           RepositoryId    id;
        attribute           Identifier      name;
        attribute           VersionSpec     version;
        // read interface
        readonly attribute  Container       defined_in;
        readonly attribute  ScopedName      absolute_name;
        readonly attribute  Repository      containing_repository;
        struct Description {
            DefinitionKind  kind;
            any            value; 
        }; 
        Description         describe ();
        // write interface
        void                move (  in Container    new_container,
                                    in Identifier   new_name,
                                    in VersionSpec  new_version
        );
    };
    interface ModuleDef;
    interface ConstantDef;
    interface IDLType;
    interface StructDef;
    interface UnionDef;
    interface EnumDef;
    interface AliasDef;
    interface InterfaceDef;
    interface ExceptionDef;
    interface NativeDef;
    typedef sequence <InterfaceDef> InterfaceDefSeq;
    interface  ValueDef;
    typedef sequence <ValueDef> ValueDefSeq;
    interface ValueBoxDef;

    
    enum OperationMode {OP_NORMAL, OP_ONEWAY};
    enum ParameterMode {PARAM_IN, PARAM_OUT, PARAM_INOUT};
    struct ParameterDescription {
        Identifier                      name; 
        TypeCode                        type; 
        IDLType                       type_def;
        ParameterMode                   mode;
    };

    typedef short Visibility;
    const Visibility PRIVATE_MEMBER = 0;
    const Visibility PUBLIC_MEMBER  = 1;
    
    struct ValueMember {
#       pragma version ValueMember 2.3
        Identifier                      name;
        RepositoryId                    id;
        RepositoryId                    defined_in;
        VersionSpec                     version;
        TypeCode                        type;
        IDLType                       type_def;
        Visibility                      access; 
    };

    typedef sequence <ExceptionDef>         ExceptionDefSeq;

	
    struct StructMember {
        Identifier          name;
        TypeCode            type;
        IDLType             type_def;
    };
    typedef sequence <StructMember> StructMemberSeq;
    struct Initializer {
#       pragma version Initializer 2.3
        StructMemberSeq     members;
        Identifier          name;
    };
    typedef sequence <Initializer> InitializerSeq;
     struct UnionMember {
        Identifier          name;
        any                label;
        TypeCode            type;
        IDLType             type_def;
    };
    typedef sequence <UnionMember> UnionMemberSeq;
    typedef sequence <Identifier> EnumMemberSeq;
    interface Container : IRObject {
#       pragma version Container 2.3
        // read interface
        Contained lookup (
            in ScopedName                   search_name);
        ContainedSeq contents (
            in DefinitionKind               limit_type,
            in boolean                      exclude_inherited
        );
        ContainedSeq lookup_name (
            in Identifier                   search_name, 
            in long                         levels_to_search, 
            in DefinitionKind               limit_type,
            in boolean                      exclude_inherited
        );
        struct Description {
            Contained                       contained_object; 
            DefinitionKind                  kind;
            any                            value; 
        };
        typedef sequence<Description> DescriptionSeq;
        DescriptionSeq describe_contents (
            in DefinitionKind               limit_type,
            in boolean                      exclude_inherited,
            in long                         max_returned_objs
        );
        // write interface
        ModuleDef create_module (
            in RepositoryId                 id,
            in Identifier                   name,
            in VersionSpec                  version
        );
        ConstantDef create_constant (
            in RepositoryId                 id,
            in Identifier                   name,
            in VersionSpec                  version,
            in IDLType                      type,
            in any                         value
        );
        StructDef create_struct (
            in RepositoryId                 id,
            in Identifier                   name,
            in VersionSpec                  version,
            in StructMemberSeq              members
        );
        UnionDef create_union (
            in RepositoryId                 id,
            in Identifier                   name,
            in VersionSpec                  version,
            in IDLType                      discriminator_type,
            in UnionMemberSeq               members
        );
        EnumDef create_enum (
            in RepositoryId                 id,
            in Identifier                   name,
            in VersionSpec                  version,
            in EnumMemberSeq                members
        );
        AliasDef create_alias (
            in RepositoryId                 id,
            in Identifier                   name,
            in VersionSpec                  version,
            in IDLType                      original_type
        );
        InterfaceDef create_interface (
            in RepositoryId                 id,
            in Identifier                   name,
            in VersionSpec                  version,
            in InterfaceDefSeq              base_interfaces,
            in boolean                      is_abstract
        );
        ValueDef create_value(
            in RepositoryId                 id,
            in Identifier                   name,
            in VersionSpec                  version,
            in boolean                      is_custom,
            in boolean                      is_abstract,
            in ValueDef                    base_value,
            in boolean                      is_truncatable,
            in ValueDefSeq                  abstract_base_values,
            in InterfaceDefSeq              supported_interfaces,
            in InitializerSeq               initializers
        );
        ValueBoxDef create_value_box(
            in RepositoryId                 id,
            in Identifier                   name,
            in VersionSpec                  version,
            in IDLType                      original_type_def
        );
        ExceptionDef create_exception(
            in RepositoryId                 id,
            in Identifier                   name,
            in VersionSpec                  version,
            in StructMemberSeq              members
        );
        NativeDef create_native(
            in RepositoryId                 id,
            in Identifier                   name,
            in VersionSpec                  version
        );
    };
    interface IDLType : IRObject {
#       pragma version IDLType 2.3
        readonly attribute TypeCode     type;
    };

    enum PrimitiveKind {
#       pragma version PrimitiveKind 2.3
        pk_null,    pk_void,      pk_short,     pk_long,   pk_ushort,
        pk_ulong,
        pk_float,   pk_double,    pk_boolean,   pk_char,   pk_octet,
        pk_any,     pk_TypeCode,  pk_Principal, pk_string, pk_objref,
        pk_longlong,pk_ulonglong, pk_longdouble, 
        pk_wchar,   pk_wstring,   pk_value_base
    };
    
    interface ModuleDef : Container, Contained {
#       pragma version ModuleDef 2.3
    };
    
    struct ModuleDescription {
        Identifier                      name; 
        RepositoryId                    id; 
        RepositoryId                    defined_in;
        VersionSpec                     version;
    };

    interface ConstantDef : Contained {
#       pragma version ConstantDef 2.3
        readonly attribute TypeCode     type;
        attribute IDLType               type_def;
        attribute any                  value;
    };
    struct ConstantDescription {
        Identifier                      name; 
        RepositoryId                    id; 
        RepositoryId                    defined_in; 
        VersionSpec                     version;
        TypeCode                        type; 
        any                             value; 
    };
    
    interface TypedefDef : Contained, IDLType {
#       pragma version TypedefDef 2.3
    };
    
    struct TypeDescription {
        Identifier                      name; 
        RepositoryId                    id; 
        RepositoryId                    defined_in; 
        VersionSpec                     version;
        TypeCode                        type; 
    };
    
    interface StructDef : TypedefDef, Container {
#       pragma version StructDef 2.3
        attribute StructMemberSeq       members;
    };
    
    interface UnionDef : TypedefDef, Container {
#       pragma version UnionDef 2.3
        readonly attribute TypeCode     discriminator_type;
        attribute IDLType               discriminator_type_def;
        attribute UnionMemberSeq        members;
    };

    interface EnumDef : TypedefDef {
#       pragma version EnumDef 2.3
        attribute EnumMemberSeq         members;
    };
    interface AliasDef : TypedefDef {
#       pragma version AliasDef 2.3
        attribute IDLType               original_type_def;
    };
    interface NativeDef : TypedefDef {
#       pragma version NativeDef 2.3
    };
    interface PrimitiveDef: IDLType {
#       pragma version PrimitiveDef 2.3
        readonly attribute PrimitiveKind kind;
    };
    interface StringDef : IDLType {
#       pragma version StringDef 2.3
        attribute unsigned long         bound;
    };
    interface WstringDef : IDLType {
#       pragma version WstringDef 2.3
        attribute unsigned long         bound;
    };
    interface FixedDef : IDLType {
#       pragma version FixedDef 2.3
        attribute unsigned short        digits;
        attribute short                 scale;
    };
    interface SequenceDef : IDLType {
#       pragma version SequenceDef 2.3
        attribute unsigned long         bound;
        readonly attribute TypeCode     element_type;
        attribute IDLType               element_type_def;
    };
    interface ArrayDef : IDLType {
#       pragma version ArrayDef 2.3
        attribute unsigned long         length;
        readonly attribute TypeCode     element_type;
        attribute IDLType               element_type_def;
    };
    interface ExceptionDef : Container, Contained {
#       pragma version ExceptionDef 2.3
        readonly attribute TypeCode     type;
        attribute StructMemberSeq       members;
    };
    struct ExceptionDescription {
        Identifier                      name; 
        RepositoryId                    id; 
        RepositoryId                    defined_in; 
        VersionSpec                     version;
        TypeCode                        type; 
    };
    enum AttributeMode {ATTR_NORMAL, ATTR_READONLY};
    interface AttributeDef : Contained {
#       pragma version AttributeDef 2.3
        readonly attribute TypeCode     type;
        attribute IDLType               type_def;
        attribute AttributeMode         mode;
        };
    struct AttributeDescription {
        Identifier                      name; 
        RepositoryId                    id; 
        RepositoryId                    defined_in; 
        VersionSpec                     version;
        TypeCode                        type;
        AttributeMode                   mode; 
    };

    typedef sequence <ParameterDescription> ParDescriptionSeq;
    typedef Identifier                      ContextIdentifier;
    typedef sequence <ContextIdentifier>    ContextIdSeq;
    typedef sequence <ExceptionDescription> ExcDescriptionSeq;
    
    interface OperationDef : Contained {
#       pragma version OperationDef 2.3
        readonly attribute TypeCode     result;
        attribute IDLType               result_def;
        attribute ParDescriptionSeq     params;
        attribute OperationMode         mode; 
        attribute ContextIdSeq          contexts;
        attribute ExceptionDefSeq       exceptions;
    };
    
    struct OperationDescription {
        Identifier                      name; 
        RepositoryId                    id; 
        RepositoryId                    defined_in; 
        VersionSpec                     version;
        TypeCode                        result; 
        OperationMode                   mode; 
        ContextIdSeq                    contexts; 
        ParDescriptionSeq               parameters;
        ExcDescriptionSeq               exceptions;
    };
    typedef sequence <RepositoryId>         RepositoryIdSeq;
    typedef sequence <OperationDescription> OpDescriptionSeq;
    typedef sequence <AttributeDescription> AttrDescriptionSeq;
    
    interface InterfaceDef : Container, Contained, IDLType {
#       pragma version InterfaceDef 2.3
        // read/write interface
        attribute InterfaceDefSeq       base_interfaces;
        attribute boolean               is_abstract;
        // read interface
        boolean is_a (in RepositoryId   interface_id
        );
        struct FullInterfaceDescription {
#           pragma version FullInterfaceDescription 2.3
            Identifier                  name;
            RepositoryId                id;
            RepositoryId                defined_in;
            VersionSpec                 version;
            OpDescriptionSeq            operations;
            AttrDescriptionSeq          attributes;
            RepositoryIdSeq             base_interfaces;
            TypeCode                    type;
            boolean                     is_abstract;
        };
        FullInterfaceDescription describe_interface();
        // write interface
        AttributeDef create_attribute (
            in RepositoryId             id,
            in Identifier               name,
            in VersionSpec              version,
            in IDLType                  type,
            in AttributeMode            mode
        );
        OperationDef create_operation ( 
            in RepositoryId             id,
            in Identifier               name,
            in VersionSpec              version,
            in IDLType                  IDL_result,
            in OperationMode            mode, 
            in ParDescriptionSeq        params,
            in ExceptionDefSeq          exceptions,
            in ContextIdSeq             contexts
        );
    };
    struct InterfaceDescription {
#       pragma version InterfaceDescription 2.3
        Identifier                      name; 
        RepositoryId                    id; 
        RepositoryId                    defined_in; 
        VersionSpec                     version;
        RepositoryIdSeq                 base_interfaces;
        boolean                         is_abstract;
    };
    typedef sequence <ValueMember> ValueMemberSeq;
    interface ValueMemberDef : Contained {
#       pragma version ValueMemberDef 2.3
        readonly attribute              TypeCode type;
        attribute IDLType               type_def;
        attribute Visibility            access;
    };
    interface ValueDef : Container, Contained, IDLType {
#       pragma version ValueDef 2.3
        // read/write interface
        attribute InterfaceDefSeq       supported_interfaces;
        attribute InitializerSeq        initializers;
        attribute ValueDef              base_value;
        attribute ValueDefSeq           abstract_base_values;
        attribute boolean               is_abstract;
        attribute boolean               is_custom;
        attribute boolean               is_truncatable;
        // read interface
        boolean is_a(in RepositoryId    id);
        struct FullValueDescription {
#           pragma version FullValueDescription 2.3
            Identifier                  name;
            RepositoryId                id;
            boolean                     is_abstract;
            boolean                     is_custom;
            RepositoryId                defined_in;
            VersionSpec                 version;
            OpDescriptionSeq            operations;
            AttrDescriptionSeq          attributes;
            ValueMemberSeq              members;
            InitializerSeq              initializers;
            RepositoryIdSeq             supported_interfaces;
            RepositoryIdSeq             abstract_base_values;
            boolean                     is_truncatable;
            RepositoryId                base_value;
            TypeCode                    type;
        };
        FullValueDescription describe_value();
        ValueMemberDef create_value_member(
            in RepositoryId             id,
            in Identifier               name,
            in VersionSpec              version,
            in IDLType                  type,
            in Visibility               access
        );
        AttributeDef create_attribute(
            in RepositoryId             id,
            in Identifier               name,
            in VersionSpec              version,
            in IDLType                  type,
            in AttributeMode            mode
        );
        OperationDef create_operation (
            in RepositoryId             id,
            in Identifier               name,
            in VersionSpec              version,
            in IDLType                  IDL_result,
            in OperationMode            mode,
            in ParDescriptionSeq        params,
            in ExceptionDefSeq          exceptions,
            in ContextIdSeq             contexts
        );
    };
    struct ValueDescription {
#       pragma version ValueDescription 2.3
        Identifier                      name;
        RepositoryId                    id;
        boolean                         is_abstract;
        boolean                         is_custom;
        RepositoryId                    defined_in;
        VersionSpec                     version;
        RepositoryIdSeq                 supported_interfaces;
        RepositoryIdSeq                 abstract_base_values;
        boolean                         is_truncatable;
        RepositoryId                    base_value; 
    };
    interface ValueBoxDef : TypedefDef {
#       pragma version ValueBoxDef 2.3
        attribute IDLType original_type_def;
    };
    interface Repository : Container {
#       pragma version Repository 2.3
        // read interface
        Contained   lookup_id               (in RepositoryId    search_id);
        TypeCode    get_canonical_typecode  (in TypeCode        tc); 
        PrimitiveDef get_primitive          (in PrimitiveKind   kind);
        // write interface
        StringDef   create_string           (in unsigned long   bound);
        WstringDef  create_wstring          (in unsigned long   bound);
        SequenceDef create_sequence         (in unsigned long   bound,
                                             in IDLType         element_type
        );
        ArrayDef create_array               (in unsigned long   length,
                                             in IDLType         element_type
        );
        FixedDef create_fixed               (in unsigned short  digits,
                                             in short           scale
        );
    };
  };
};
\end{verbatim}

\chapter{Script de Modification des fichiers générés}
\label{script}
\begin{verbatim}
#!/bin/sh

for file in `ls *.ad?`; do
sed '/with CORBA.TypeCode;/ D' $file > ${file}.old
sed '/use CORBA.TypeCode;/ D' ${file}.old > $file
sed 's/with CORBA.TypeCode.Stream; use CORBA.TypeCode.Stream;/    \
     with Broca.CDR; use Broca.CDR;/g'  $file > ${file}.old
sed 's/CORBA.TypeCode.Ref/CORBA.TypeCode.Object/g'  ${file}.old > $file
sed '/with CORBA.Stream; use CORBA.Stream;/ D' $file > ${file}.old
sed '/with CORBA.TypeCode.Helper;/ D' ${file}.old > $file
sed 's/TypeCode.Helper.//g'  $file > ${file}.old
mv  ${file}.old $file 
done
rm corba.ads corba-typecode*
rm corba-stream.ad?
\end{verbatim}

\end{document}
