1) be-buffers :

   Le backend buffers génère un code optimisant l'allocation des buffers pour 
le marshalling des paramètres des méthodes invoquées. Le code généré calcule la
taille du buffer nécessaire au marshalling des paramètres et alloue un segment 
mémoire de la taille ainsi calculée, l'intérêt étant de réduire le nombre 
d'appels système (routine allocate). Dans PolyORB le marshalling des paramètres
d'une méthode se fait en appelant la méthode de marshalling sur chaque 
paramètre individuellement. Cela implique éventuellment plusieurs allocations.

   Le backend Buffers propose de remplacer les multiples allocations 
par une seule allocation effectuée avant le marshalling des paramètres.

2) Calcule de la taille du buffer
   Le calcul de la taille d'un buffer se décompose en deux parties que voici :

2.1) Alignement 
     Le protocole GIOP impose d'aligner les données transmises selon leur 
taille (à quelques exceptions près, voir spec. CORBA). Le frontend d'iac stocke
les informations relatives au type des paramètres et des attributs utilisés 
dans le fichier idl. Ces derniers sont utlisés pour calculer l'alignement pour 
chaque paramètre.

Rmq : L'alignement d'un type composé est celui des types simples le composant.

2.2) Taille pour le marshalling
     De la même manière que pour l'alignement, le type des données (paramètres)
nous permet de déterminer la taille nécessaire au marshalling de la donnée. 

2.2.1) Type simple :
       Les types simples utilisés dans la spécification CORBA sont de taille 
fixe, le calcul de la taille mémoire nécessaire est fait statiquement (lors de
la génération de code) (ex : long => 4).

2.2.2) Type composé ou non fixe (Unbounded):

	a) Struct : la taille nécessaire au marshalling est la somme des 
	tailles nécessaires à chaque attribut composant la structure. Si la 
	structure est composée d'attributs de type simple il est possible de 
	fixer sa taille de manière statique. 
	
	b) Union : la taille est égale à la taille de l'alternative utilisée
	de l'union. La taille ne peut être fixée statiquement (sauf cas 
	particulier alternarives de même taille ce cas n'est implanté dans la 
	version courante).

	c) Sequence : la taille est la somme des tailles des éléments de la
	sequence plus la taille d'un Unsigned_Long (longueur de la sequence).
	si la taille des éléments de la sequence sont fixes (struct ou simple)
	à l'exécution le calcul de la taille de la sequence est une simple 
	opération arithmétique (multiplication taille élément * longueur).

	d) Array : idem (sequence).

	e) Fixed_Point : la taille est le nombre d'octets UTILISE par le 
	paramètre plus un octet (position de la virgule). le nombre d'octets
	est calculé dynamiquement lors de l'exécution.

	f) Unbounded_String : la taille est determinée lors de l'éxecution et
	est égale à la longueur de la chaine plus la taille d'un unsigned_long
	(longueur de la chaine transmise).
	
	g) Object et Reference : la taille est celle de l'IOR. N'ayant pas 
	accès à la taille de l'IOR lors de la compilation on ne peut 
	qu'estimer sa taille.

3) Preallocation (Preallocate_Buffer):
   Une fois la taille du buffer calculée une fonction de préallocation est
appelée. Cette dernière alloue un segment mémoire sans modifier les méta-données
associées au buffer (sauf la longueur du nouveau segment).

4) Optimisations :
	Préallocation uniquement si c'est nécessaire : préallocation d'un 
   segment supérieur à 512 octets. Etant donné que le pas d'allocation dans 
   PolyORB est de 512 octets, il est inutile de préallouer un buffer de taille 
   inférieure.

	Pour les buffer de taille fixe (paramètres de taille fixe) on stocke
   la taille nécessaire pour le marshalling dans un attribut du package buffers
   pour éviter de refaire le même calcul à chaque marshalling.	