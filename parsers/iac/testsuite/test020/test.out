orb.idl:45:01: Conforming to the IDL grammar, a semi-colon is expected here
CORBA_InterfaceRepository.idl:10:01: Conforming to the IDL grammar, a semi-colon is expected here
iac: 2 warning(s)
module CORBA {
  typeprefix CORBA "omg.org";
  interface Current;
  interface DomainManager;
  interface Policy;
  interface TypeCode;
  typedef string Identifier;
  enum completion_status {
    COMPLETED_YES,
    COMPLETED_NO,
    COMPLETED_MAYBE
  };
  enum exception_type {
    NO_EXCEPTION,
    USER_EXCEPTION,
    SYSTEM_EXCEPTION
  };
  exception UNKNOWN {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_PARAM {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception NO_MEMORY {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception IMP_LIMIT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception COMM_FAILURE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INV_OBJREF {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception NO_PERMISSION {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INTERNAL {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception MARSHAL {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INITIALIZE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception NO_IMPLEMENT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_TYPECODE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_OPERATION {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception NO_RESOURCES {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception NO_RESPONSE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception PERSIST_STORE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_INV_ORDER {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TRANSIENT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception FREE_MEM {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INV_IDENT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INV_FLAG {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INTF_REPOS {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_CONTEXT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception OBJ_ADAPTER {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception DATA_CONVERSION {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception OBJECT_NOT_EXIST {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TRANSACTION_REQUIRED {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TRANSACTION_ROLLEDBACK {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INVALID_TRANSACTION {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INV_POLICY {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception CODESET_INCOMPATIBLE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception REBIND {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TIMEOUT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TRANSACTION_UNAVAILABLE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TRANSACTION_MODE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_QOS {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  local interface Current {
};
  typedef unsigned long PolicyType;
  interface Policy {
    readonly attribute CORBA::PolicyType policy_type;
    CORBA::PolicyType Get_policy_type();
    CORBA::Policy copy();
    void destroy();
  };
  typedef sequence<CORBA::Policy> PolicyList;
  typedef sequence<CORBA::PolicyType> PolicyTypeSeq;
  exception InvalidPolicies {
    sequence<unsigned short> indices;
  };
  typedef short PolicyErrorCode;
  exception PolicyError {
    CORBA::PolicyErrorCode reason;
  };
  const CORBA::PolicyErrorCode BAD_POLICY = 0;
  const CORBA::PolicyErrorCode UNSUPPORTED_POLICY = 1;
  const CORBA::PolicyErrorCode BAD_POLICY_TYPE = 2;
  const CORBA::PolicyErrorCode BAD_POLICY_VALUE = 3;
  const CORBA::PolicyErrorCode UNSUPPORTED_POLICY_VALUE = 4;
  interface DomainManager {
    CORBA::Policy get_domain_policy(in CORBA::PolicyType policy_type);
  };
  typedef sequence<CORBA::DomainManager> DomainManagersList;
  typeprefix CORBA "omg.org";
  typedef string ScopedName;
  typedef string RepositoryId;
  typedef short Visibility;
  const CORBA::Visibility PRIVATE_MEMBER = 0;
  const CORBA::Visibility PUBLIC_MEMBER = 1;
  typeprefix CORBA "omg.org";
  enum TCKind {
    tk_null,
    tk_void,
    tk_short,
    tk_long,
    tk_ushort,
    tk_ulong,
    tk_float,
    tk_double,
    tk_boolean,
    tk_char,
    tk_octet,
    tk_any,
    tk_TypeCode,
    tk_Principal,
    tk_objref,
    tk_struct,
    tk_union,
    tk_enum,
    tk_string,
    tk_sequence,
    tk_array,
    tk_alias,
    tk_except,
    tk_longlong,
    tk_ulonglong,
    tk_longdouble,
    tk_wchar,
    tk_wstring,
    tk_fixed,
    tk_value,
    tk_value_box,
    tk_native,
    tk_abstract_interface,
    tk_local_interface,
    tk_component,
    tk_home,
    tk_event
  };
  typedef short ValueModifier;
  const CORBA::ValueModifier VM_NONE = 0;
  const CORBA::ValueModifier VM_CUSTOM = 1;
  const CORBA::ValueModifier VM_ABSTRACT = 2;
  const CORBA::ValueModifier VM_TRUNCATABLE = 3;
  interface TypeCode {
    exception Bounds {
    };
    exception BadKind {
    };
    boolean equal(in CORBA::TypeCode tc);
    boolean equivalent(in CORBA::TypeCode tc);
    CORBA::TypeCode get_compact_typecode();
    CORBA::TCKind kind();
    CORBA::RepositoryId id() raises (CORBA::TypeCode::BadKind);
    CORBA::Identifier name() raises (CORBA::TypeCode::BadKind);
    unsigned long member_count() raises (CORBA::TypeCode::BadKind);
    CORBA::Identifier member_name(in unsigned long index) raises (CORBA::TypeCode::BadKind, CORBA::TypeCode::Bounds);
    CORBA::TypeCode member_type(in unsigned long index) raises (CORBA::TypeCode::BadKind, CORBA::TypeCode::Bounds);
    any member_label(in unsigned long index) raises (CORBA::TypeCode::BadKind, CORBA::TypeCode::Bounds);
    CORBA::TypeCode discriminator_type() raises (CORBA::TypeCode::BadKind);
    long default_index() raises (CORBA::TypeCode::BadKind);
    unsigned long length() raises (CORBA::TypeCode::BadKind);
    CORBA::TypeCode content_type() raises (CORBA::TypeCode::BadKind);
    unsigned short fixed_digits() raises (CORBA::TypeCode::BadKind);
    short fixed_scale() raises (CORBA::TypeCode::BadKind);
    CORBA::Visibility member_visibility(in unsigned long index) raises (CORBA::TypeCode::BadKind, CORBA::TypeCode::Bounds);
    CORBA::ValueModifier type_modifier() raises (CORBA::TypeCode::BadKind);
    CORBA::TypeCode concrete_base_type() raises (CORBA::TypeCode::BadKind);
  };
  interface CContext;
  interface NVList;
  interface OObject;
  interface ORB;
  interface Request;
  interface ServerRequest;
  typedef unsigned long Flags;
  struct NamedValue {
    CORBA::Identifier name;
    any argument;
    long len;
    CORBA::Flags arg_modes;
  };
  enum SetOverrideType {
    SET_OVERRIDE,
    ADD_OVERRIDE
  };
  interface OObject {
    CORBA::Repository_Root::InterfaceDef get_interface();
    boolean is_nil();
    CORBA::OObject duplicate();
    void release();
    boolean is_a(in string logical_type_id);
    boolean non_existent();
    boolean is_equivalent(in CORBA::OObject other_object);
    unsigned long hash(in unsigned long maximum);
    void create_request(in CORBA::CContext ctx, in CORBA::Identifier operation, in CORBA::NVList arg_list, inout CORBA::NamedValue result, out CORBA::Request request, in CORBA::Flags req_flag);
    CORBA::Policy get_policy(in CORBA::PolicyType policy_type);
    CORBA::DomainManagersList get_domain_managers();
    CORBA::OObject set_policy_overrides(in CORBA::PolicyList policies, in CORBA::SetOverrideType set_add) raises (CORBA::InvalidPolicies);
    CORBA::Policy get_client_policy(in CORBA::PolicyType type);
    CORBA::PolicyList get_policy_overrides(in CORBA::PolicyTypeSeq types);
  };
  native AbstractBase;
  typedef unsigned short ServiceType;
  typedef unsigned long ServiceOption;
  typedef unsigned long ServiceDetailType;
  const CORBA::ServiceType Security = 1;
  typedef sequence<octet> IDL_AT_Sequence_octet;
  struct ServiceDetail {
    CORBA::ServiceDetailType service_detail_type;
    CORBA::IDL_AT_Sequence_octet service_detail;
  };
  typedef sequence<CORBA::ServiceOption> IDL_AT_Sequence_CORBA_ServiceOption;
  typedef sequence<CORBA::ServiceDetail> IDL_AT_Sequence_CORBA_ServiceDetail;
  struct ServiceInformation {
    CORBA::IDL_AT_Sequence_CORBA_ServiceOption service_options;
    CORBA::IDL_AT_Sequence_CORBA_ServiceDetail service_details;
  };
  typedef string ORBid;
  interface ORB {
    typedef string ObjectId;
    typedef sequence<CORBA::ORB::ObjectId> ObjectIdList;
    exception InvalidName {
    };
    string object_to_string(in CORBA::OObject obj);
    CORBA::OObject string_to_object(in string str);
    void create_list(in long count, out CORBA::NVList new_list);
    void get_default_context(out CORBA::CContext ctx);
    boolean get_service_information(in CORBA::ServiceType service_type, out CORBA::ServiceInformation service_information);
    CORBA::ORB::ObjectIdList list_initial_services();
    CORBA::OObject resolve_initial_references(in CORBA::ORB::ObjectId identifier) raises (CORBA::ORB::InvalidName);
    CORBA::TypeCode create_alias_tc(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::TypeCode original_type);
    CORBA::TypeCode create_interface_tc(in CORBA::RepositoryId id, in CORBA::Identifier name);
    CORBA::TypeCode create_string_tc(in unsigned long bound);
    CORBA::TypeCode create_wstring_tc(in unsigned long bound);
    CORBA::TypeCode create_fixed_tc(in unsigned short digits, in short scale);
    CORBA::TypeCode create_sequence_tc(in unsigned long bound, in CORBA::TypeCode element_type);
    CORBA::TypeCode create_recursive_sequence_tc(in unsigned long bound, in unsigned long offset);
    CORBA::TypeCode create_array_tc(in unsigned long length, in CORBA::TypeCode element_type);
    CORBA::TypeCode create_native_tc(in CORBA::RepositoryId id, in CORBA::Identifier name);
    boolean work_pending();
    void perform_work();
    void run();
    void shutdown(in boolean wait_for_completion);
    CORBA::Policy create_policy(in CORBA::PolicyType type, in any val) raises (CORBA::PolicyError);
    void register_initial_reference(in CORBA::ORB::ObjectId id, in CORBA::OObject obj) raises (CORBA::ORB::InvalidName);
  };
  interface Request {
    void invoke(in CORBA::Flags invoke_flags);
    void delete();
  };
  interface CContext {
    void set_one_value(in CORBA::Identifier prop_name, in string value);
    void set_values(in CORBA::NVList values);
    void get_values(in CORBA::Identifier start_scope, in CORBA::Flags op_flags, in CORBA::Identifier prop_name, out CORBA::NVList values);
    void delete_values(in CORBA::Identifier prop_name);
    void create_child(in CORBA::Identifier ctx_name, out CORBA::CContext child_ctx);
    void delete(in CORBA::Flags del_flags);
  };
  interface NVList {
    void free();
    void free_memory();
    void get_count(out long count);
  };
  interface ServerRequest {
    readonly attribute CORBA::Identifier operation;
    CORBA::Identifier Get_operation();
    void arguments(inout CORBA::NVList nv);
    CORBA::CContext ctx();
    void set_result(in any val);
    void set_exception(in any val);
  };
  module Repository_Root {
    interface ArrayDef;
    interface AttributeDef;
    interface Contained;
    interface Container;
    interface FixedDef;
    interface IRObject;
    interface OperationDef;
    interface PrimitiveDef;
    interface Repository;
    interface SequenceDef;
    interface StringDef;
    interface TypedefDef;
    interface ValueMemberDef;
    interface WstringDef;
    enum DefinitionKind {
      dk_none,
      dk_all,
      dk_Attribute,
      dk_Constant,
      dk_Exception,
      dk_Interface,
      dk_Module,
      dk_Operation,
      dk_Typedef,
      dk_Alias,
      dk_Struct,
      dk_Union,
      dk_Enum,
      dk_Primitive,
      dk_String,
      dk_Sequence,
      dk_Array,
      dk_Repository,
      dk_Wstring,
      dk_Fixed,
      dk_Value,
      dk_ValueBox,
      dk_ValueMember,
      dk_Native,
      dk_AbstractInterface,
      dk_LocalInterface,
      dk_Component,
      dk_Home,
      dk_Factory,
      dk_Finder,
      dk_Emits,
      dk_Publishes,
      dk_Consumes,
      dk_Provides,
      dk_Uses,
      dk_Event
    };
    interface IRObject {
      readonly attribute CORBA::Repository_Root::DefinitionKind def_kind;
      CORBA::Repository_Root::DefinitionKind Get_def_kind();
      void destroy();
    };
    typedef string VersionSpec;
    interface Contained : CORBA::Repository_Root::IRObject {
      attribute CORBA::RepositoryId id;
      CORBA::RepositoryId Get_id();
      void Set_id(in CORBA::RepositoryId To);
      attribute CORBA::Identifier name;
      CORBA::Identifier Get_name();
      void Set_name(in CORBA::Identifier To);
      attribute CORBA::Repository_Root::VersionSpec version;
      CORBA::Repository_Root::VersionSpec Get_version();
      void Set_version(in CORBA::Repository_Root::VersionSpec To);
      readonly attribute CORBA::Repository_Root::Container defined_in;
      CORBA::Repository_Root::Container Get_defined_in();
      readonly attribute CORBA::ScopedName absolute_name;
      CORBA::ScopedName Get_absolute_name();
      readonly attribute CORBA::Repository_Root::Repository containing_repository;
      CORBA::Repository_Root::Repository Get_containing_repository();
      struct Description {
        CORBA::Repository_Root::DefinitionKind kind;
        any value;
      };
      CORBA::Repository_Root::Contained::Description describe();
      void move(in CORBA::Repository_Root::Container new_container, in CORBA::Identifier new_name, in CORBA::Repository_Root::VersionSpec new_version);
    };
    interface ModuleDef;
    interface ConstantDef;
    interface IDLType;
    interface StructDef;
    interface UnionDef;
    interface EnumDef;
    interface AliasDef;
    interface ExceptionDef;
    interface NativeDef;
    interface InterfaceDef;
    typedef sequence<CORBA::Repository_Root::InterfaceDef> InterfaceDefSeq;
    interface ValueDef;
    typedef sequence<CORBA::Repository_Root::ValueDef> ValueDefSeq;
    interface ValueBoxDef;
    interface AbstractInterfaceDef;
    typedef sequence<CORBA::Repository_Root::AbstractInterfaceDef> AbstractInterfaceDefSeq;
    interface LocalInterfaceDef;
    typedef sequence<CORBA::Repository_Root::LocalInterfaceDef> LocalInterfaceDefSeq;
    interface ExtInterfaceDef;
    typedef sequence<CORBA::Repository_Root::ExtInterfaceDef> ExtInterfaceDefSeq;
    interface ExtAbstractInterfaceDef;
    typedef sequence<CORBA::Repository_Root::ExtAbstractInterfaceDef> ExtAbstractInterfaceDefSeq;
    interface ExtLocalInterfaceDef;
    typedef sequence<CORBA::Repository_Root::ExtLocalInterfaceDef> ExtLocalInterfaceDefSeq;
    typedef sequence<CORBA::Repository_Root::Contained> ContainedSeq;
    struct StructMember {
      CORBA::Identifier name;
      CORBA::TypeCode type;
      CORBA::Repository_Root::IDLType type_def;
    };
    typedef sequence<CORBA::Repository_Root::StructMember> StructMemberSeq;
    struct Initializer {
      CORBA::Repository_Root::StructMemberSeq members;
      CORBA::Identifier name;
    };
    typedef sequence<CORBA::Repository_Root::Initializer> InitializerSeq;
    struct UnionMember {
      CORBA::Identifier name;
      any label;
      CORBA::TypeCode type;
      CORBA::Repository_Root::IDLType type_def;
    };
    struct ExceptionDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      CORBA::RepositoryId defined_in;
      CORBA::Repository_Root::VersionSpec version;
      CORBA::TypeCode type;
    };
    typedef sequence<CORBA::Repository_Root::ExceptionDescription> ExcDescriptionSeq;
    struct ExtInitializer {
      CORBA::Repository_Root::StructMemberSeq members;
      CORBA::Repository_Root::ExcDescriptionSeq exceptions;
      CORBA::Identifier name;
    };
    typedef sequence<CORBA::Repository_Root::ExtInitializer> ExtInitializerSeq;
    typedef sequence<CORBA::Repository_Root::UnionMember> UnionMemberSeq;
    typedef sequence<CORBA::Identifier> EnumMemberSeq;
    interface Container : CORBA::Repository_Root::IRObject {
      CORBA::Repository_Root::Contained lookup(in CORBA::ScopedName search_name);
      CORBA::Repository_Root::ContainedSeq contents(in CORBA::Repository_Root::DefinitionKind limit_type, in boolean exclude_inherited);
      CORBA::Repository_Root::ContainedSeq lookup_name(in CORBA::Identifier search_name, in long levels_to_search, in CORBA::Repository_Root::DefinitionKind limit_type, in boolean exclude_inherited);
      struct Description {
        CORBA::Repository_Root::Contained contained_object;
        CORBA::Repository_Root::DefinitionKind kind;
        any value;
      };
      typedef sequence<CORBA::Repository_Root::Container::Description> DescriptionSeq;
      CORBA::Repository_Root::Container::DescriptionSeq describe_contents(in CORBA::Repository_Root::DefinitionKind limit_type, in boolean exclude_inherited, in long max_returned_objs);
      CORBA::Repository_Root::ModuleDef create_module(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version);
      CORBA::Repository_Root::ConstantDef create_constant(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::IDLType type, in any value);
      CORBA::Repository_Root::StructDef create_struct(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::StructMemberSeq members);
      CORBA::Repository_Root::UnionDef create_union(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::IDLType discriminator_type, in CORBA::Repository_Root::UnionMemberSeq members);
      CORBA::Repository_Root::EnumDef create_enum(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::EnumMemberSeq members);
      CORBA::Repository_Root::AliasDef create_alias(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::IDLType original_type);
      CORBA::Repository_Root::InterfaceDef create_interface(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::InterfaceDefSeq base_interfaces, in boolean is_abstract);
      CORBA::Repository_Root::ValueDef create_value(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in boolean is_custom, in boolean is_abstract, in CORBA::Repository_Root::ValueDef base_value, in boolean is_truncatable, in CORBA::Repository_Root::ValueDefSeq abstract_base_values, in CORBA::Repository_Root::InterfaceDefSeq supported_interfaces, in CORBA::Repository_Root::InitializerSeq initializers);
      CORBA::Repository_Root::ValueBoxDef create_value_box(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::IDLType original_type_def);
      CORBA::Repository_Root::ExceptionDef create_exception(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::StructMemberSeq members);
      CORBA::Repository_Root::NativeDef create_native(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version);
      CORBA::Repository_Root::AbstractInterfaceDef create_abstract_interface(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::AbstractInterfaceDefSeq base_interfaces);
      CORBA::Repository_Root::LocalInterfaceDef create_local_interface(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::InterfaceDefSeq base_interfaces);
    };
    interface IDLType : CORBA::Repository_Root::IRObject {
      readonly attribute CORBA::TypeCode type;
      CORBA::TypeCode Get_type();
    };
    enum PrimitiveKind {
      pk_null,
      pk_void,
      pk_short,
      pk_long,
      pk_ushort,
      pk_ulong,
      pk_float,
      pk_double,
      pk_boolean,
      pk_char,
      pk_octet,
      pk_any,
      pk_TypeCode,
      pk_Principal,
      pk_string,
      pk_objref,
      pk_longlong,
      pk_ulonglong,
      pk_longdouble,
      pk_wchar,
      pk_wstring,
      pk_value_base
    };
    interface Repository : CORBA::Repository_Root::Container {
      CORBA::Repository_Root::Contained lookup_id(in CORBA::RepositoryId search_id);
      CORBA::TypeCode get_canonical_typecode(in CORBA::TypeCode tc);
      CORBA::Repository_Root::PrimitiveDef get_primitive(in CORBA::Repository_Root::PrimitiveKind kind);
      CORBA::Repository_Root::StringDef create_string(in unsigned long bound);
      CORBA::Repository_Root::WstringDef create_wstring(in unsigned long bound);
      CORBA::Repository_Root::SequenceDef create_sequence(in unsigned long bound, in CORBA::Repository_Root::IDLType element_type);
      CORBA::Repository_Root::ArrayDef create_array(in unsigned long length, in CORBA::Repository_Root::IDLType element_type);
      CORBA::Repository_Root::FixedDef create_fixed(in unsigned short digits, in short scale);
    };
    interface ModuleDef : CORBA::Repository_Root::Container, CORBA::Repository_Root::Contained {
};
    struct ModuleDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      CORBA::RepositoryId defined_in;
      CORBA::Repository_Root::VersionSpec version;
    };
    interface ConstantDef : CORBA::Repository_Root::Contained {
      readonly attribute CORBA::TypeCode type;
      CORBA::TypeCode Get_type();
      attribute CORBA::Repository_Root::IDLType type_def;
      CORBA::Repository_Root::IDLType Get_type_def();
      void Set_type_def(in CORBA::Repository_Root::IDLType To);
      attribute any value;
      any Get_value();
      void Set_value(in any To);
    };
    struct ConstantDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      CORBA::RepositoryId defined_in;
      CORBA::Repository_Root::VersionSpec version;
      CORBA::TypeCode type;
      any value;
    };
    interface TypedefDef : CORBA::Repository_Root::Contained, CORBA::Repository_Root::IDLType {
};
    struct TypeDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      CORBA::RepositoryId defined_in;
      CORBA::Repository_Root::VersionSpec version;
      CORBA::TypeCode type;
    };
    interface StructDef : CORBA::Repository_Root::TypedefDef, CORBA::Repository_Root::Container {
      attribute CORBA::Repository_Root::StructMemberSeq members;
      CORBA::Repository_Root::StructMemberSeq Get_members();
      void Set_members(in CORBA::Repository_Root::StructMemberSeq To);
    };
    interface UnionDef : CORBA::Repository_Root::TypedefDef, CORBA::Repository_Root::Container {
      readonly attribute CORBA::TypeCode discriminator_type;
      CORBA::TypeCode Get_discriminator_type();
      attribute CORBA::Repository_Root::IDLType discriminator_type_def;
      CORBA::Repository_Root::IDLType Get_discriminator_type_def();
      void Set_discriminator_type_def(in CORBA::Repository_Root::IDLType To);
      attribute CORBA::Repository_Root::UnionMemberSeq members;
      CORBA::Repository_Root::UnionMemberSeq Get_members();
      void Set_members(in CORBA::Repository_Root::UnionMemberSeq To);
    };
    interface EnumDef : CORBA::Repository_Root::TypedefDef {
      attribute CORBA::Repository_Root::EnumMemberSeq members;
      CORBA::Repository_Root::EnumMemberSeq Get_members();
      void Set_members(in CORBA::Repository_Root::EnumMemberSeq To);
    };
    interface AliasDef : CORBA::Repository_Root::TypedefDef {
      attribute CORBA::Repository_Root::IDLType original_type_def;
      CORBA::Repository_Root::IDLType Get_original_type_def();
      void Set_original_type_def(in CORBA::Repository_Root::IDLType To);
    };
    interface NativeDef : CORBA::Repository_Root::TypedefDef {
};
    interface PrimitiveDef : CORBA::Repository_Root::IDLType {
      readonly attribute CORBA::Repository_Root::PrimitiveKind kind;
      CORBA::Repository_Root::PrimitiveKind Get_kind();
    };
    interface StringDef : CORBA::Repository_Root::IDLType {
      attribute unsigned long bound;
      unsigned long Get_bound();
      void Set_bound(in unsigned long To);
    };
    interface WstringDef : CORBA::Repository_Root::IDLType {
      attribute unsigned long bound;
      unsigned long Get_bound();
      void Set_bound(in unsigned long To);
    };
    interface FixedDef : CORBA::Repository_Root::IDLType {
      attribute unsigned short digits;
      unsigned short Get_digits();
      void Set_digits(in unsigned short To);
      attribute short scale;
      short Get_scale();
      void Set_scale(in short To);
    };
    interface SequenceDef : CORBA::Repository_Root::IDLType {
      attribute unsigned long bound;
      unsigned long Get_bound();
      void Set_bound(in unsigned long To);
      readonly attribute CORBA::TypeCode element_type;
      CORBA::TypeCode Get_element_type();
      attribute CORBA::Repository_Root::IDLType element_type_def;
      CORBA::Repository_Root::IDLType Get_element_type_def();
      void Set_element_type_def(in CORBA::Repository_Root::IDLType To);
    };
    interface ArrayDef : CORBA::Repository_Root::IDLType {
      attribute unsigned long length;
      unsigned long Get_length();
      void Set_length(in unsigned long To);
      readonly attribute CORBA::TypeCode element_type;
      CORBA::TypeCode Get_element_type();
      attribute CORBA::Repository_Root::IDLType element_type_def;
      CORBA::Repository_Root::IDLType Get_element_type_def();
      void Set_element_type_def(in CORBA::Repository_Root::IDLType To);
    };
    interface ExceptionDef : CORBA::Repository_Root::Contained, CORBA::Repository_Root::Container {
      readonly attribute CORBA::TypeCode type;
      CORBA::TypeCode Get_type();
      attribute CORBA::Repository_Root::StructMemberSeq members;
      CORBA::Repository_Root::StructMemberSeq Get_members();
      void Set_members(in CORBA::Repository_Root::StructMemberSeq To);
    };
    enum AttributeMode {
      ATTR_NORMAL,
      ATTR_READONLY
    };
    interface AttributeDef : CORBA::Repository_Root::Contained {
      readonly attribute CORBA::TypeCode type;
      CORBA::TypeCode Get_type();
      attribute CORBA::Repository_Root::IDLType type_def;
      CORBA::Repository_Root::IDLType Get_type_def();
      void Set_type_def(in CORBA::Repository_Root::IDLType To);
      attribute CORBA::Repository_Root::AttributeMode mode;
      CORBA::Repository_Root::AttributeMode Get_mode();
      void Set_mode(in CORBA::Repository_Root::AttributeMode To);
    };
    struct AttributeDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      CORBA::RepositoryId defined_in;
      CORBA::Repository_Root::VersionSpec version;
      CORBA::TypeCode type;
      CORBA::Repository_Root::AttributeMode mode;
    };
    struct ExtAttributeDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      CORBA::RepositoryId defined_in;
      CORBA::Repository_Root::VersionSpec version;
      CORBA::TypeCode type;
      CORBA::Repository_Root::AttributeMode mode;
      CORBA::Repository_Root::ExcDescriptionSeq get_exceptions;
      CORBA::Repository_Root::ExcDescriptionSeq put_exceptions;
    };
    interface ExtAttributeDef : CORBA::Repository_Root::AttributeDef {
      attribute CORBA::Repository_Root::ExcDescriptionSeq get_exceptions;
      CORBA::Repository_Root::ExcDescriptionSeq Get_get_exceptions();
      void Set_get_exceptions(in CORBA::Repository_Root::ExcDescriptionSeq To);
      attribute CORBA::Repository_Root::ExcDescriptionSeq set_exceptions;
      CORBA::Repository_Root::ExcDescriptionSeq Get_set_exceptions();
      void Set_set_exceptions(in CORBA::Repository_Root::ExcDescriptionSeq To);
      CORBA::Repository_Root::ExtAttributeDescription describe_attribute();
    };
    enum OperationMode {
      OP_NORMAL,
      OP_ONEWAY
    };
    enum ParameterMode {
      PARAM_IN,
      PARAM_OUT,
      PARAM_INOUT
    };
    struct ParameterDescription {
      CORBA::Identifier name;
      CORBA::TypeCode type;
      CORBA::Repository_Root::IDLType type_def;
      CORBA::Repository_Root::ParameterMode mode;
    };
    typedef sequence<CORBA::Repository_Root::ParameterDescription> ParDescriptionSeq;
    typedef CORBA::Identifier ContextIdentifier;
    typedef sequence<CORBA::Repository_Root::ContextIdentifier> ContextIdSeq;
    typedef sequence<CORBA::Repository_Root::ExceptionDef> ExceptionDefSeq;
    interface OperationDef : CORBA::Repository_Root::Contained {
      readonly attribute CORBA::TypeCode result;
      CORBA::TypeCode Get_result();
      attribute CORBA::Repository_Root::IDLType result_def;
      CORBA::Repository_Root::IDLType Get_result_def();
      void Set_result_def(in CORBA::Repository_Root::IDLType To);
      attribute CORBA::Repository_Root::ParDescriptionSeq params;
      CORBA::Repository_Root::ParDescriptionSeq Get_params();
      void Set_params(in CORBA::Repository_Root::ParDescriptionSeq To);
      attribute CORBA::Repository_Root::OperationMode mode;
      CORBA::Repository_Root::OperationMode Get_mode();
      void Set_mode(in CORBA::Repository_Root::OperationMode To);
      attribute CORBA::Repository_Root::ContextIdSeq contexts;
      CORBA::Repository_Root::ContextIdSeq Get_contexts();
      void Set_contexts(in CORBA::Repository_Root::ContextIdSeq To);
      attribute CORBA::Repository_Root::ExceptionDefSeq exceptions;
      CORBA::Repository_Root::ExceptionDefSeq Get_exceptions();
      void Set_exceptions(in CORBA::Repository_Root::ExceptionDefSeq To);
    };
    struct OperationDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      CORBA::RepositoryId defined_in;
      CORBA::Repository_Root::VersionSpec version;
      CORBA::TypeCode result;
      CORBA::Repository_Root::OperationMode mode;
      CORBA::Repository_Root::ContextIdSeq contexts;
      CORBA::Repository_Root::ParDescriptionSeq parameters;
      CORBA::Repository_Root::ExcDescriptionSeq exceptions;
    };
    typedef sequence<CORBA::RepositoryId> RepositoryIdSeq;
    typedef sequence<CORBA::Repository_Root::OperationDescription> OpDescriptionSeq;
    typedef sequence<CORBA::Repository_Root::AttributeDescription> AttrDescriptionSeq;
    typedef sequence<CORBA::Repository_Root::ExtAttributeDescription> ExtAttrDescriptionSeq;
    interface InterfaceDef : CORBA::Repository_Root::Container, CORBA::Repository_Root::Contained, CORBA::Repository_Root::IDLType {
      attribute CORBA::Repository_Root::InterfaceDefSeq base_interfaces;
      CORBA::Repository_Root::InterfaceDefSeq Get_base_interfaces();
      void Set_base_interfaces(in CORBA::Repository_Root::InterfaceDefSeq To);
      attribute boolean is_abstract;
      boolean Get_is_abstract();
      void Set_is_abstract(in boolean To);
      boolean is_a(in CORBA::RepositoryId interface_id);
      struct FullInterfaceDescription {
        CORBA::Identifier name;
        CORBA::RepositoryId id;
        CORBA::RepositoryId defined_in;
        CORBA::Repository_Root::VersionSpec version;
        CORBA::Repository_Root::OpDescriptionSeq operations;
        CORBA::Repository_Root::AttrDescriptionSeq attributes;
        CORBA::Repository_Root::RepositoryIdSeq base_interfaces;
        CORBA::TypeCode type;
        boolean is_abstract;
      };
      CORBA::Repository_Root::InterfaceDef::FullInterfaceDescription describe_interface();
      CORBA::Repository_Root::AttributeDef create_attribute(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::IDLType type, in CORBA::Repository_Root::AttributeMode mode);
      CORBA::Repository_Root::OperationDef create_operation(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::IDLType result, in CORBA::Repository_Root::OperationMode mode, in CORBA::Repository_Root::ParDescriptionSeq params, in CORBA::Repository_Root::ExceptionDefSeq exceptions, in CORBA::Repository_Root::ContextIdSeq contexts);
    };
    struct InterfaceDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      CORBA::RepositoryId defined_in;
      CORBA::Repository_Root::VersionSpec version;
      CORBA::Repository_Root::RepositoryIdSeq base_interfaces;
      boolean is_abstract;
    };
    interface InterfaceAttrExtension {
      struct ExtFullInterfaceDescription {
        CORBA::Identifier name;
        CORBA::RepositoryId id;
        CORBA::RepositoryId defined_in;
        CORBA::Repository_Root::VersionSpec version;
        CORBA::Repository_Root::OpDescriptionSeq operations;
        CORBA::Repository_Root::ExtAttrDescriptionSeq attributes;
        CORBA::Repository_Root::RepositoryIdSeq base_interfaces;
        CORBA::TypeCode type;
      };
      CORBA::Repository_Root::InterfaceAttrExtension::ExtFullInterfaceDescription describe_ext_interface();
      CORBA::Repository_Root::ExtAttributeDef create_ext_attribute(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::IDLType type, in CORBA::Repository_Root::AttributeMode mode, in CORBA::Repository_Root::ExceptionDefSeq get_exceptions, in CORBA::Repository_Root::ExceptionDefSeq set_exceptions);
    };
    interface ExtInterfaceDef : CORBA::Repository_Root::InterfaceDef, CORBA::Repository_Root::InterfaceAttrExtension {
};
    struct ValueMember {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      CORBA::RepositoryId defined_in;
      CORBA::Repository_Root::VersionSpec version;
      CORBA::TypeCode type;
      CORBA::Repository_Root::IDLType type_def;
      CORBA::Visibility access;
    };
    typedef sequence<CORBA::Repository_Root::ValueMember> ValueMemberSeq;
    interface ValueMemberDef : CORBA::Repository_Root::Contained {
      readonly attribute CORBA::TypeCode type;
      CORBA::TypeCode Get_type();
      attribute CORBA::Repository_Root::IDLType type_def;
      CORBA::Repository_Root::IDLType Get_type_def();
      void Set_type_def(in CORBA::Repository_Root::IDLType To);
      attribute CORBA::Visibility access;
      CORBA::Visibility Get_access();
      void Set_access(in CORBA::Visibility To);
    };
    interface ValueDef : CORBA::Repository_Root::Container, CORBA::Repository_Root::Contained, CORBA::Repository_Root::IDLType {
      attribute CORBA::Repository_Root::InterfaceDefSeq supported_interfaces;
      CORBA::Repository_Root::InterfaceDefSeq Get_supported_interfaces();
      void Set_supported_interfaces(in CORBA::Repository_Root::InterfaceDefSeq To);
      attribute CORBA::Repository_Root::InitializerSeq initializers;
      CORBA::Repository_Root::InitializerSeq Get_initializers();
      void Set_initializers(in CORBA::Repository_Root::InitializerSeq To);
      attribute CORBA::Repository_Root::ValueDef base_value;
      CORBA::Repository_Root::ValueDef Get_base_value();
      void Set_base_value(in CORBA::Repository_Root::ValueDef To);
      attribute CORBA::Repository_Root::ValueDefSeq abstract_base_values;
      CORBA::Repository_Root::ValueDefSeq Get_abstract_base_values();
      void Set_abstract_base_values(in CORBA::Repository_Root::ValueDefSeq To);
      attribute boolean is_abstract;
      boolean Get_is_abstract();
      void Set_is_abstract(in boolean To);
      attribute boolean is_custom;
      boolean Get_is_custom();
      void Set_is_custom(in boolean To);
      attribute boolean is_truncatable;
      boolean Get_is_truncatable();
      void Set_is_truncatable(in boolean To);
      boolean is_a(in CORBA::RepositoryId id);
      struct FullValueDescription {
        CORBA::Identifier name;
        CORBA::RepositoryId id;
        boolean is_abstract;
        boolean is_custom;
        CORBA::RepositoryId defined_in;
        CORBA::Repository_Root::VersionSpec version;
        CORBA::Repository_Root::OpDescriptionSeq operations;
        CORBA::Repository_Root::AttrDescriptionSeq attributes;
        CORBA::Repository_Root::ValueMemberSeq members;
        CORBA::Repository_Root::InitializerSeq initializers;
        CORBA::Repository_Root::RepositoryIdSeq supported_interfaces;
        CORBA::Repository_Root::RepositoryIdSeq abstract_base_values;
        boolean is_truncatable;
        CORBA::RepositoryId base_value;
        CORBA::TypeCode type;
      };
      CORBA::Repository_Root::ValueDef::FullValueDescription describe_value();
      CORBA::Repository_Root::ValueMemberDef create_value_member(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::IDLType type, in CORBA::Visibility access);
      CORBA::Repository_Root::AttributeDef create_attribute(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::IDLType type, in CORBA::Repository_Root::AttributeMode mode);
      CORBA::Repository_Root::OperationDef create_operation(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::Repository_Root::VersionSpec version, in CORBA::Repository_Root::IDLType result, in CORBA::Repository_Root::OperationMode mode, in CORBA::Repository_Root::ParDescriptionSeq params, in CORBA::Repository_Root::ExceptionDefSeq exceptions, in CORBA::Repository_Root::ContextIdSeq contexts);
    };
    struct ValueDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      boolean is_abstract;
      boolean is_custom;
      CORBA::RepositoryId defined_in;
      CORBA::Repository_Root::VersionSpec version;
      CORBA::Repository_Root::RepositoryIdSeq supported_interfaces;
      CORBA::Repository_Root::RepositoryIdSeq abstract_base_values;
      boolean is_truncatable;
      CORBA::RepositoryId base_value;
    };
    interface ValueBoxDef : CORBA::Repository_Root::TypedefDef {
      attribute CORBA::Repository_Root::IDLType original_type_def;
      CORBA::Repository_Root::IDLType Get_original_type_def();
      void Set_original_type_def(in CORBA::Repository_Root::IDLType To);
    };
    interface AbstractInterfaceDef : CORBA::Repository_Root::InterfaceDef {
};
    interface ExtAbstractInterfaceDef : CORBA::Repository_Root::AbstractInterfaceDef, CORBA::Repository_Root::InterfaceAttrExtension {
};
    interface LocalInterfaceDef : CORBA::Repository_Root::InterfaceDef {
};
    interface ExtLocalInterfaceDef : CORBA::Repository_Root::LocalInterfaceDef, CORBA::Repository_Root::InterfaceAttrExtension {
};
  };
  module IDL_Sequences {
    typedef sequence<any> AnySeq;
    typedef sequence<boolean> BooleanSeq;
    typedef sequence<char> CharSeq;
    typedef sequence<wchar> WCharSeq;
    typedef sequence<octet> OctetSeq;
    typedef sequence<short> ShortSeq;
    typedef sequence<unsigned short> UShortSeq;
    typedef sequence<long> LongSeq;
    typedef sequence<unsigned long> ULongSeq;
    typedef sequence<long long> LongLongSeq;
    typedef sequence<unsigned long long> ULongLongSeq;
    typedef sequence<float> FloatSeq;
    typedef sequence<double> DoubleSeq;
    typedef sequence<long double> LongDoubleSeq;
    typedef sequence<string> StringSeq;
    typedef sequence<wstring> WStringSeq;
  };
};
enum EggPlant {
  Banana,
  Carrots,
  Lemon,
  BlackCherry,
  Starfruit,
  Rhubarb
};
typedef sequence<float> IDL_AT_Sequence_float;
typedef IDL_AT_Sequence_float Plum[18];
struct Zucchini {
  short Pumpkin;
};
typedef Zucchini Avocado;
union Lentil switch (long) {
    case 23 :
    octet Lime;
    case -25 :
    Avocado Coconut;
    default :
    short Lychees;
};
interface siiServer {
  attribute float Cucumber;
  float Get_Cucumber();
  void Set_Cucumber(in float To);
  attribute double Ginger;
  double Get_Ginger();
  void Set_Ginger(in double To);
  attribute long Apricots;
  long Get_Apricots();
  void Set_Apricots(in long To);
  attribute unsigned long BlackEyedBeans;
  unsigned long Get_BlackEyedBeans();
  void Set_BlackEyedBeans(in unsigned long To);
  attribute short Leek;
  short Get_Leek();
  void Set_Leek(in short To);
  attribute unsigned short Mint;
  unsigned short Get_Mint();
  void Set_Mint(in unsigned short To);
  attribute char GardenPeas;
  char Get_GardenPeas();
  void Set_GardenPeas(in char To);
  attribute boolean Fig;
  boolean Get_Fig();
  void Set_Fig(in boolean To);
  attribute octet Asparagus;
  octet Get_Asparagus();
  void Set_Asparagus(in octet To);
  attribute string GaliaMelon;
  string Get_GaliaMelon();
  void Set_GaliaMelon(in string To);
  attribute string<23> Sultana;
  typedef string<23> IDL_AT_String_23;
  siiServer::IDL_AT_String_23 Get_Sultana();
  typedef string<23> IDL_AT_String_23_1;
  void Set_Sultana(in siiServer::IDL_AT_String_23_1 To);
  attribute CORBA::OObject Turnip;
  CORBA::OObject Get_Turnip();
  void Set_Turnip(in CORBA::OObject To);
  attribute any Orange;
  any Get_Orange();
  void Set_Orange(in any To);
  attribute CORBA::TypeCode LoganBerry;
  CORBA::TypeCode Get_LoganBerry();
  void Set_LoganBerry(in CORBA::TypeCode To);
  readonly attribute float Parsnip;
  float Get_Parsnip();
  readonly attribute double Celery;
  double Get_Celery();
  readonly attribute long WhiteCabbage;
  long Get_WhiteCabbage();
  readonly attribute unsigned long Aniseed;
  unsigned long Get_Aniseed();
  readonly attribute short Bayleaf;
  short Get_Bayleaf();
  readonly attribute unsigned short Dill;
  unsigned short Get_Dill();
  readonly attribute char Oregano;
  char Get_Oregano();
  readonly attribute boolean Beansprout;
  boolean Get_Beansprout();
  readonly attribute octet Almonds;
  octet Get_Almonds();
  readonly attribute string Guava;
  string Get_Guava();
  readonly attribute string<25> Mushroom;
  typedef string<25> IDL_AT_String_25;
  siiServer::IDL_AT_String_25 Get_Mushroom();
  readonly attribute CORBA::OObject Runnerbean;
  CORBA::OObject Get_Runnerbean();
  readonly attribute any Tofu;
  any Get_Tofu();
  readonly attribute CORBA::TypeCode Prunes;
  CORBA::TypeCode Get_Prunes();
  attribute EggPlant GrannySmith;
  EggPlant Get_GrannySmith();
  void Set_GrannySmith(in EggPlant To);
  attribute Plum SweetPotato;
  Plum Get_SweetPotato();
  void Set_SweetPotato(in Plum To);
  attribute Zucchini Billberries;
  Zucchini Get_Billberries();
  void Set_Billberries(in Zucchini To);
  attribute Avocado LolloRossa;
  Avocado Get_LolloRossa();
  void Set_LolloRossa(in Avocado To);
  attribute Lentil Sweetcorn;
  Lentil Get_Sweetcorn();
  void Set_Sweetcorn(in Lentil To);
  readonly attribute EggPlant Shallots;
  EggPlant Get_Shallots();
  readonly attribute Plum KidneyBean;
  Plum Get_KidneyBean();
  readonly attribute Zucchini ButterBean;
  Zucchini Get_ButterBean();
  readonly attribute Avocado GoldenDelicous;
  Avocado Get_GoldenDelicous();
  readonly attribute Lentil CrabApple;
  Lentil Get_CrabApple();
  attribute long RedOnion, HazelNut, Cinnamon, GooseBerry;
  long Get_GooseBerry();
  void Set_GooseBerry(in long To);
  long Get_Cinnamon();
  void Set_Cinnamon(in long To);
  long Get_HazelNut();
  void Set_HazelNut(in long To);
  long Get_RedOnion();
  void Set_RedOnion(in long To);
  attribute EggPlant JuniperBerries, Cloves, Daikan, Mustard;
  EggPlant Get_Mustard();
  void Set_Mustard(in EggPlant To);
  EggPlant Get_Daikan();
  void Set_Daikan(in EggPlant To);
  EggPlant Get_Cloves();
  void Set_Cloves(in EggPlant To);
  EggPlant Get_JuniperBerries();
  void Set_JuniperBerries(in EggPlant To);
};
