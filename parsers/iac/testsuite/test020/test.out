module CORBA {
  interface Current;
  interface DomainManager;
  interface Policy;
  interface ArrayDef;
  interface AttributeDef;
  interface Contained;
  interface Container;
  interface FixedDef;
  interface IRObject;
  interface OperationDef;
  interface PrimitiveDef;
  interface Repository;
  interface SequenceDef;
  interface StringDef;
  interface TypeCode;
  interface TypedefDef;
  interface ValueMemberDef;
  interface WstringDef;
  typedef string Identifier;
  enum completion_status {
    COMPLETED_YES,
    COMPLETED_NO,
    COMPLETED_MAYBE
  };
  enum exception_type {
    NO_EXCEPTION,
    USER_EXCEPTION,
    SYSTEM_EXCEPTION
  };
  exception UNKNOWN {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_PARAM {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception NO_MEMORY {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception IMP_LIMIT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception COMM_FAILURE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INV_OBJREF {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception NO_PERMISSION {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INTERNAL {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception MARSHAL {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INITIALIZE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception NO_IMPLEMENT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_TYPECODE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_OPERATION {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception NO_RESOURCES {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception NO_RESPONSE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception PERSIST_STORE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_INV_ORDER {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TRANSIENT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception FREE_MEM {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INV_IDENT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INV_FLAG {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INTF_REPOS {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_CONTEXT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception OBJ_ADAPTER {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception DATA_CONVERSION {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception OBJECT_NOT_EXIST {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TRANSACTION_REQUIRED {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TRANSACTION_ROLLEDBACK {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INVALID_TRANSACTION {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception INV_POLICY {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception CODESET_INCOMPATIBLE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception REBIND {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TIMEOUT {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TRANSACTION_UNAVAILABLE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception TRANSACTION_MODE {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  exception BAD_QOS {
    unsigned long minor;
    CORBA::completion_status completed;
  };
  local interface Current {
};
  typedef unsigned long PolicyType;
  interface Policy {
    readonly attribute CORBA::PolicyType policy_type;
    CORBA::Policy copy();
    void destroy();
  };
  typedef sequence<CORBA::Policy> PolicyList;
  typedef sequence<CORBA::PolicyType> PolicyTypeSeq;
  exception InvalidPolicies {
    sequence<unsigned short> indices;
  };
  typedef short PolicyErrorCode;
  exception PolicyError {
    CORBA::PolicyErrorCode reason;
  };
  const CORBA::PolicyErrorCode BAD_POLICY = 0;
  const CORBA::PolicyErrorCode UNSUPPORTED_POLICY = 1;
  const CORBA::PolicyErrorCode BAD_POLICY_TYPE = 2;
  const CORBA::PolicyErrorCode BAD_POLICY_VALUE = 3;
  const CORBA::PolicyErrorCode UNSUPPORTED_POLICY_VALUE = 4;
  interface DomainManager {
    CORBA::Policy get_domain_policy(in CORBA::PolicyType policy_type);
  };
  typedef sequence<CORBA::DomainManager> DomainManagersList;
  typedef string ScopedName;
  typedef string RepositoryId;
  enum DefinitionKind {
    dk_none,
    dk_all,
    dk_Attribute,
    dk_Constant,
    dk_Exception,
    dk_Interface,
    dk_Module,
    dk_Operation,
    dk_Typedef,
    dk_Alias,
    dk_Struct,
    dk_Union,
    dk_Enum,
    dk_Primitive,
    dk_String,
    dk_Sequence,
    dk_Array,
    dk_Repository,
    dk_Wstring,
    dk_Fixed,
    dk_Value,
    dk_ValueBox,
    dk_ValueMember,
    dk_Native,
    dk_AbstractInterface,
    dk_LocalInterface,
    dk_Component,
    dk_Home,
    dk_Factory,
    dk_Finder,
    dk_Emits,
    dk_Publishes,
    dk_Consumes,
    dk_Provides,
    dk_Uses,
    dk_Event
  };
  interface IRObject {
    readonly attribute CORBA::DefinitionKind def_kind;
    void destroy();
  };
  typedef string VersionSpec;
  interface Contained : CORBA::IRObject {
    attribute CORBA::RepositoryId id;
    attribute CORBA::Identifier name;
    attribute CORBA::VersionSpec version;
    readonly attribute CORBA::Container defined_in;
    readonly attribute CORBA::ScopedName absolute_name;
    readonly attribute CORBA::Repository containing_repository;
    struct Description {
      CORBA::DefinitionKind kind;
      any value;
    };
    CORBA::Contained::Description describe();
    void move(in CORBA::Container new_container, in CORBA::Identifier new_name, in CORBA::VersionSpec new_version);
  };
  interface ModuleDef;
  interface ConstantDef;
  interface IDLType;
  interface StructDef;
  interface UnionDef;
  interface EnumDef;
  interface AliasDef;
  interface ExceptionDef;
  interface NativeDef;
  interface InterfaceDef;
  typedef sequence<CORBA::InterfaceDef> InterfaceDefSeq;
  interface ValueDef;
  typedef sequence<CORBA::ValueDef> ValueDefSeq;
  interface ValueBoxDef;
  interface AbstractInterfaceDef;
  typedef sequence<CORBA::AbstractInterfaceDef> AbstractInterfaceDefSeq;
  interface LocalInterfaceDef;
  typedef sequence<CORBA::LocalInterfaceDef> LocalInterfaceDefSeq;
  interface ExtInterfaceDef;
  typedef sequence<CORBA::ExtInterfaceDef> ExtInterfaceDefSeq;
  interface ExtAbstractInterfaceDef;
  typedef sequence<CORBA::ExtAbstractInterfaceDef> ExtAbstractInterfaceDefSeq;
  interface ExtLocalInterfaceDef;
  typedef sequence<CORBA::ExtLocalInterfaceDef> ExtLocalInterfaceDefSeq;
  typedef sequence<CORBA::Contained> ContainedSeq;
  struct StructMember {
    CORBA::Identifier name;
    CORBA::TypeCode type;
    CORBA::IDLType type_def;
  };
  typedef sequence<CORBA::StructMember> StructMemberSeq;
  struct Initializer {
    CORBA::StructMemberSeq members;
    CORBA::Identifier name;
  };
  typedef sequence<CORBA::Initializer> InitializerSeq;
  struct UnionMember {
    CORBA::Identifier name;
    any label;
    CORBA::TypeCode type;
    CORBA::IDLType type_def;
  };
  struct ExceptionDescription {
    CORBA::Identifier name;
    CORBA::RepositoryId id;
    CORBA::RepositoryId defined_in;
    CORBA::VersionSpec version;
    CORBA::TypeCode type;
  };
  typedef sequence<CORBA::ExceptionDescription> ExcDescriptionSeq;
  struct ExtInitializer {
    CORBA::StructMemberSeq members;
    CORBA::ExcDescriptionSeq exceptions;
    CORBA::Identifier name;
  };
  typedef sequence<CORBA::ExtInitializer> ExtInitializerSeq;
  typedef sequence<CORBA::UnionMember> UnionMemberSeq;
  typedef sequence<CORBA::Identifier> EnumMemberSeq;
  interface Container : CORBA::IRObject {
    CORBA::Contained lookup(in CORBA::ScopedName search_name);
    CORBA::ContainedSeq contents(in CORBA::DefinitionKind limit_type, in boolean exclude_inherited);
    CORBA::ContainedSeq lookup_name(in CORBA::Identifier search_name, in long levels_to_search, in CORBA::DefinitionKind limit_type, in boolean exclude_inherited);
    struct Description {
      CORBA::Contained contained_object;
      CORBA::DefinitionKind kind;
      any value;
    };
    typedef sequence<CORBA::Container::Description> DescriptionSeq;
    CORBA::Container::DescriptionSeq describe_contents(in CORBA::DefinitionKind limit_type, in boolean exclude_inherited, in long max_returned_objs);
    CORBA::ModuleDef create_module(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version);
    CORBA::ConstantDef create_constant(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::IDLType type, in any value);
    CORBA::StructDef create_struct(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::StructMemberSeq members);
    CORBA::UnionDef create_union(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::IDLType discriminator_type, in CORBA::UnionMemberSeq members);
    CORBA::EnumDef create_enum(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::EnumMemberSeq members);
    CORBA::AliasDef create_alias(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::IDLType original_type);
    CORBA::InterfaceDef create_interface(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::InterfaceDefSeq base_interfaces, in boolean is_abstract);
    CORBA::ValueDef create_value(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in boolean is_custom, in boolean is_abstract, in CORBA::ValueDef base_value, in boolean is_truncatable, in CORBA::ValueDefSeq abstract_base_values, in CORBA::InterfaceDefSeq supported_interfaces, in CORBA::InitializerSeq initializers);
    CORBA::ValueBoxDef create_value_box(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::IDLType original_type_def);
    CORBA::ExceptionDef create_exception(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::StructMemberSeq members);
    CORBA::NativeDef create_native(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version);
    CORBA::AbstractInterfaceDef create_abstract_interface(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::AbstractInterfaceDefSeq base_interfaces);
    CORBA::LocalInterfaceDef create_local_interface(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::InterfaceDefSeq base_interfaces);
  };
  interface IDLType : CORBA::IRObject {
    readonly attribute CORBA::TypeCode type;
  };
  enum PrimitiveKind {
    pk_null,
    pk_void,
    pk_short,
    pk_long,
    pk_ushort,
    pk_ulong,
    pk_float,
    pk_double,
    pk_boolean,
    pk_char,
    pk_octet,
    pk_any,
    pk_TypeCode,
    pk_Principal,
    pk_string,
    pk_objref,
    pk_longlong,
    pk_ulonglong,
    pk_longdouble,
    pk_wchar,
    pk_wstring,
    pk_value_base
  };
  interface Repository : CORBA::Container {
    CORBA::Contained lookup_id(in CORBA::RepositoryId search_id);
    CORBA::TypeCode get_canonical_typecode(in CORBA::TypeCode tc);
    CORBA::PrimitiveDef get_primitive(in CORBA::PrimitiveKind kind);
    CORBA::StringDef create_string(in unsigned long bound);
    CORBA::WstringDef create_wstring(in unsigned long bound);
    CORBA::SequenceDef create_sequence(in unsigned long bound, in CORBA::IDLType element_type);
    CORBA::ArrayDef create_array(in unsigned long length, in CORBA::IDLType element_type);
    CORBA::FixedDef create_fixed(in unsigned short digits, in short scale);
  };
  interface ModuleDef : CORBA::Container, CORBA::Contained {
};
  struct ModuleDescription {
    CORBA::Identifier name;
    CORBA::RepositoryId id;
    CORBA::RepositoryId defined_in;
    CORBA::VersionSpec version;
  };
  interface ConstantDef : CORBA::Contained {
    readonly attribute CORBA::TypeCode type;
    attribute CORBA::IDLType type_def;
    attribute any value;
  };
  struct ConstantDescription {
    CORBA::Identifier name;
    CORBA::RepositoryId id;
    CORBA::RepositoryId defined_in;
    CORBA::VersionSpec version;
    CORBA::TypeCode type;
    any value;
  };
  interface TypedefDef : CORBA::Contained, CORBA::IDLType {
};
  struct TypeDescription {
    CORBA::Identifier name;
    CORBA::RepositoryId id;
    CORBA::RepositoryId defined_in;
    CORBA::VersionSpec version;
    CORBA::TypeCode type;
  };
  interface StructDef : CORBA::TypedefDef, CORBA::Container {
    attribute CORBA::StructMemberSeq members;
  };
  interface UnionDef : CORBA::TypedefDef, CORBA::Container {
    readonly attribute CORBA::TypeCode discriminator_type;
    attribute CORBA::IDLType discriminator_type_def;
    attribute CORBA::UnionMemberSeq members;
  };
  interface EnumDef : CORBA::TypedefDef {
    attribute CORBA::EnumMemberSeq members;
  };
  interface AliasDef : CORBA::TypedefDef {
    attribute CORBA::IDLType original_type_def;
  };
  interface NativeDef : CORBA::TypedefDef {
};
  interface PrimitiveDef : CORBA::IDLType {
    readonly attribute CORBA::PrimitiveKind kind;
  };
  interface StringDef : CORBA::IDLType {
    attribute unsigned long bound;
  };
  interface WstringDef : CORBA::IDLType {
    attribute unsigned long bound;
  };
  interface FixedDef : CORBA::IDLType {
    attribute unsigned short digits;
    attribute short scale;
  };
  interface SequenceDef : CORBA::IDLType {
    attribute unsigned long bound;
    readonly attribute CORBA::TypeCode element_type;
    attribute CORBA::IDLType element_type_def;
  };
  interface ArrayDef : CORBA::IDLType {
    attribute unsigned long length;
    readonly attribute CORBA::TypeCode element_type;
    attribute CORBA::IDLType element_type_def;
  };
  interface ExceptionDef : CORBA::Contained, CORBA::Container {
    readonly attribute CORBA::TypeCode type;
    attribute CORBA::StructMemberSeq members;
  };
  enum AttributeMode {
    ATTR_NORMAL,
    ATTR_READONLY
  };
  interface AttributeDef : CORBA::Contained {
    readonly attribute CORBA::TypeCode type;
    attribute CORBA::IDLType type_def;
    attribute CORBA::AttributeMode mode;
  };
  struct AttributeDescription {
    CORBA::Identifier name;
    CORBA::RepositoryId id;
    CORBA::RepositoryId defined_in;
    CORBA::VersionSpec version;
    CORBA::TypeCode type;
    CORBA::AttributeMode mode;
  };
  struct ExtAttributeDescription {
    CORBA::Identifier name;
    CORBA::RepositoryId id;
    CORBA::RepositoryId defined_in;
    CORBA::VersionSpec version;
    CORBA::TypeCode type;
    CORBA::AttributeMode mode;
    CORBA::ExcDescriptionSeq get_exceptions;
    CORBA::ExcDescriptionSeq put_exceptions;
  };
  interface ExtAttributeDef : CORBA::AttributeDef {
    attribute CORBA::ExcDescriptionSeq get_exceptions;
    attribute CORBA::ExcDescriptionSeq set_exceptions;
    CORBA::ExtAttributeDescription describe_attribute();
  };
  enum OperationMode {
    OP_NORMAL,
    OP_ONEWAY
  };
  enum ParameterMode {
    PARAM_IN,
    PARAM_OUT,
    PARAM_INOUT
  };
  struct ParameterDescription {
    CORBA::Identifier name;
    CORBA::TypeCode type;
    CORBA::IDLType type_def;
    CORBA::ParameterMode mode;
  };
  typedef sequence<CORBA::ParameterDescription> ParDescriptionSeq;
  typedef CORBA::Identifier ContextIdentifier;
  typedef sequence<CORBA::ContextIdentifier> ContextIdSeq;
  typedef sequence<CORBA::ExceptionDef> ExceptionDefSeq;
  interface OperationDef : CORBA::Contained {
    readonly attribute CORBA::TypeCode result;
    attribute CORBA::IDLType result_def;
    attribute CORBA::ParDescriptionSeq params;
    attribute CORBA::OperationMode mode;
    attribute CORBA::ContextIdSeq contexts;
    attribute CORBA::ExceptionDefSeq exceptions;
  };
  struct OperationDescription {
    CORBA::Identifier name;
    CORBA::RepositoryId id;
    CORBA::RepositoryId defined_in;
    CORBA::VersionSpec version;
    CORBA::TypeCode result;
    CORBA::OperationMode mode;
    CORBA::ContextIdSeq contexts;
    CORBA::ParDescriptionSeq parameters;
    CORBA::ExcDescriptionSeq exceptions;
  };
  typedef sequence<CORBA::RepositoryId> RepositoryIdSeq;
  typedef sequence<CORBA::OperationDescription> OpDescriptionSeq;
  typedef sequence<CORBA::AttributeDescription> AttrDescriptionSeq;
  typedef sequence<CORBA::ExtAttributeDescription> ExtAttrDescriptionSeq;
  interface InterfaceDef : CORBA::Container, CORBA::Contained, CORBA::IDLType {
    attribute CORBA::InterfaceDefSeq base_interfaces;
    attribute boolean is_abstract;
    boolean is_a(in CORBA::RepositoryId interface_id);
    struct FullInterfaceDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      CORBA::RepositoryId defined_in;
      CORBA::VersionSpec version;
      CORBA::OpDescriptionSeq operations;
      CORBA::AttrDescriptionSeq attributes;
      CORBA::RepositoryIdSeq base_interfaces;
      CORBA::TypeCode type;
      boolean is_abstract;
    };
    CORBA::InterfaceDef::FullInterfaceDescription describe_interface();
    CORBA::AttributeDef create_attribute(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::IDLType type, in CORBA::AttributeMode mode);
    CORBA::OperationDef create_operation(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::IDLType result, in CORBA::OperationMode mode, in CORBA::ParDescriptionSeq params, in CORBA::ExceptionDefSeq exceptions, in CORBA::ContextIdSeq contexts);
  };
  struct InterfaceDescription {
    CORBA::Identifier name;
    CORBA::RepositoryId id;
    CORBA::RepositoryId defined_in;
    CORBA::VersionSpec version;
    CORBA::RepositoryIdSeq base_interfaces;
    boolean is_abstract;
  };
  interface InterfaceAttrExtension {
    struct ExtFullInterfaceDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      CORBA::RepositoryId defined_in;
      CORBA::VersionSpec version;
      CORBA::OpDescriptionSeq operations;
      CORBA::ExtAttrDescriptionSeq attributes;
      CORBA::RepositoryIdSeq base_interfaces;
      CORBA::TypeCode type;
    };
    CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription describe_ext_interface();
    CORBA::ExtAttributeDef create_ext_attribute(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::IDLType type, in CORBA::AttributeMode mode, in CORBA::ExceptionDefSeq get_exceptions, in CORBA::ExceptionDefSeq set_exceptions);
  };
  interface ExtInterfaceDef : CORBA::InterfaceDef, CORBA::InterfaceAttrExtension {
};
  typedef short Visibility;
  const CORBA::Visibility PRIVATE_MEMBER = 0;
  const CORBA::Visibility PUBLIC_MEMBER = 1;
  struct ValueMember {
    CORBA::Identifier name;
    CORBA::RepositoryId id;
    CORBA::RepositoryId defined_in;
    CORBA::VersionSpec version;
    CORBA::TypeCode type;
    CORBA::IDLType type_def;
    CORBA::Visibility access;
  };
  typedef sequence<CORBA::ValueMember> ValueMemberSeq;
  interface ValueMemberDef : CORBA::Contained {
    readonly attribute CORBA::TypeCode type;
    attribute CORBA::IDLType type_def;
    attribute CORBA::Visibility access;
  };
  interface ValueDef : CORBA::Container, CORBA::Contained, CORBA::IDLType {
    attribute CORBA::InterfaceDefSeq supported_interfaces;
    attribute CORBA::InitializerSeq initializers;
    attribute CORBA::ValueDef base_value;
    attribute CORBA::ValueDefSeq abstract_base_values;
    attribute boolean is_abstract;
    attribute boolean is_custom;
    attribute boolean is_truncatable;
    boolean is_a(in CORBA::RepositoryId id);
    struct FullValueDescription {
      CORBA::Identifier name;
      CORBA::RepositoryId id;
      boolean is_abstract;
      boolean is_custom;
      CORBA::RepositoryId defined_in;
      CORBA::VersionSpec version;
      CORBA::OpDescriptionSeq operations;
      CORBA::AttrDescriptionSeq attributes;
      CORBA::ValueMemberSeq members;
      CORBA::InitializerSeq initializers;
      CORBA::RepositoryIdSeq supported_interfaces;
      CORBA::RepositoryIdSeq abstract_base_values;
      boolean is_truncatable;
      CORBA::RepositoryId base_value;
      CORBA::TypeCode type;
    };
    CORBA::ValueDef::FullValueDescription describe_value();
    CORBA::ValueMemberDef create_value_member(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::IDLType type, in CORBA::Visibility access);
    CORBA::AttributeDef create_attribute(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::IDLType type, in CORBA::AttributeMode mode);
    CORBA::OperationDef create_operation(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::VersionSpec version, in CORBA::IDLType result, in CORBA::OperationMode mode, in CORBA::ParDescriptionSeq params, in CORBA::ExceptionDefSeq exceptions, in CORBA::ContextIdSeq contexts);
  };
  struct ValueDescription {
    CORBA::Identifier name;
    CORBA::RepositoryId id;
    boolean is_abstract;
    boolean is_custom;
    CORBA::RepositoryId defined_in;
    CORBA::VersionSpec version;
    CORBA::RepositoryIdSeq supported_interfaces;
    CORBA::RepositoryIdSeq abstract_base_values;
    boolean is_truncatable;
    CORBA::RepositoryId base_value;
  };
  interface ValueBoxDef : CORBA::TypedefDef {
    attribute CORBA::IDLType original_type_def;
  };
  interface AbstractInterfaceDef : CORBA::InterfaceDef {
};
  interface ExtAbstractInterfaceDef : CORBA::AbstractInterfaceDef, CORBA::InterfaceAttrExtension {
};
  interface LocalInterfaceDef : CORBA::InterfaceDef {
};
  interface ExtLocalInterfaceDef : CORBA::LocalInterfaceDef, CORBA::InterfaceAttrExtension {
};
  enum TCKind {
    tk_null,
    tk_void,
    tk_short,
    tk_long,
    tk_ushort,
    tk_ulong,
    tk_float,
    tk_double,
    tk_boolean,
    tk_char,
    tk_octet,
    tk_any,
    tk_TypeCode,
    tk_Principal,
    tk_objref,
    tk_struct,
    tk_union,
    tk_enum,
    tk_string,
    tk_sequence,
    tk_array,
    tk_alias,
    tk_except,
    tk_longlong,
    tk_ulonglong,
    tk_longdouble,
    tk_wchar,
    tk_wstring,
    tk_fixed,
    tk_value,
    tk_value_box,
    tk_native,
    tk_abstract_interface,
    tk_local_interface,
    tk_component,
    tk_home,
    tk_event
  };
  typedef short ValueModifier;
  const CORBA::ValueModifier VM_NONE = 0;
  const CORBA::ValueModifier VM_CUSTOM = 1;
  const CORBA::ValueModifier VM_ABSTRACT = 2;
  const CORBA::ValueModifier VM_TRUNCATABLE = 3;
  interface TypeCode {
    exception Bounds {
    };
    exception BadKind {
    };
    boolean equal(in CORBA::TypeCode tc);
    boolean equivalent(in CORBA::TypeCode tc);
    CORBA::TypeCode get_compact_typecode();
    CORBA::TCKind kind();
    CORBA::RepositoryId id() raises (CORBA::TypeCode::BadKind);
    CORBA::Identifier name() raises (CORBA::TypeCode::BadKind);
    unsigned long member_count() raises (CORBA::TypeCode::BadKind);
    CORBA::Identifier member_name(in unsigned long index) raises (CORBA::TypeCode::BadKind, CORBA::TypeCode::Bounds);
    CORBA::TypeCode member_type(in unsigned long index) raises (CORBA::TypeCode::BadKind, CORBA::TypeCode::Bounds);
    any member_label(in unsigned long index) raises (CORBA::TypeCode::BadKind, CORBA::TypeCode::Bounds);
    CORBA::TypeCode discriminator_type() raises (CORBA::TypeCode::BadKind);
    long default_index() raises (CORBA::TypeCode::BadKind);
    unsigned long length() raises (CORBA::TypeCode::BadKind);
    CORBA::TypeCode content_type() raises (CORBA::TypeCode::BadKind);
    unsigned short fixed_digits() raises (CORBA::TypeCode::BadKind);
    short fixed_scale() raises (CORBA::TypeCode::BadKind);
    CORBA::Visibility member_visibility(in unsigned long index) raises (CORBA::TypeCode::BadKind, CORBA::TypeCode::Bounds);
    CORBA::ValueModifier type_modifier() raises (CORBA::TypeCode::BadKind);
    CORBA::TypeCode concrete_base_type() raises (CORBA::TypeCode::BadKind);
  };
  typedef sequence<any> AnySeq;
  typedef sequence<boolean> BooleanSeq;
  typedef sequence<char> CharSeq;
  typedef sequence<wchar> WCharSeq;
  typedef sequence<octet> OctetSeq;
  typedef sequence<short> ShortSeq;
  typedef sequence<unsigned short> UShortSeq;
  typedef sequence<long> LongSeq;
  typedef sequence<unsigned long> ULongSeq;
  typedef sequence<long long> LongLongSeq;
  typedef sequence<unsigned long long> ULongLongSeq;
  typedef sequence<float> FloatSeq;
  typedef sequence<double> DoubleSeq;
  typedef sequence<long double> LongDoubleSeq;
  typedef sequence<string> StringSeq;
  typedef sequence<wstring> WStringSeq;
  interface CContext;
  interface NVList;
  interface OObject;
  interface ORB;
  interface Request;
  interface ServerRequest;
  typedef unsigned long Flags;
  struct NamedValue {
    CORBA::Identifier name;
    any argument;
    long len;
    CORBA::Flags arg_modes;
  };
  enum SetOverrideType {
    SET_OVERRIDE,
    ADD_OVERRIDE
  };
  interface OObject {
    CORBA::InterfaceDef get_interface();
    boolean is_nil();
    CORBA::OObject duplicate();
    void release();
    boolean is_a(in string logical_type_id);
    boolean non_existent();
    boolean is_equivalent(in CORBA::OObject other_object);
    unsigned long hash(in unsigned long maximum);
    void create_request(in CORBA::CContext ctx, in CORBA::Identifier operation, in CORBA::NVList arg_list, inout CORBA::NamedValue result, out CORBA::Request request, in CORBA::Flags req_flag);
    CORBA::Policy get_policy(in CORBA::PolicyType policy_type);
    CORBA::DomainManagersList get_domain_managers();
    CORBA::OObject set_policy_overrides(in CORBA::PolicyList policies, in CORBA::SetOverrideType set_add) raises (CORBA::InvalidPolicies);
    CORBA::Policy get_client_policy(in CORBA::PolicyType type);
    CORBA::PolicyList get_policy_overrides(in CORBA::PolicyTypeSeq types);
  };
  native AbstractBase;
  typedef unsigned short ServiceType;
  typedef unsigned long ServiceOption;
  typedef unsigned long ServiceDetailType;
  const CORBA::ServiceType Security = 1;
  struct ServiceDetail {
    CORBA::ServiceDetailType service_detail_type;
    sequence<octet> service_detail;
  };
  struct ServiceInformation {
    sequence<CORBA::ServiceOption> service_options;
    sequence<CORBA::ServiceDetail> service_details;
  };
  typedef string ORBid;
  interface ORB {
    typedef string ObjectId;
    typedef sequence<CORBA::ORB::ObjectId> ObjectIdList;
    exception InvalidName {
    };
    string object_to_string(in CORBA::OObject obj);
    CORBA::OObject string_to_object(in string str);
    void create_list(in long count, out CORBA::NVList new_list);
    void get_default_context(out CORBA::CContext ctx);
    boolean get_service_information(in CORBA::ServiceType service_type, out CORBA::ServiceInformation service_information);
    CORBA::ORB::ObjectIdList list_initial_services();
    CORBA::OObject resolve_initial_references(in CORBA::ORB::ObjectId identifier) raises (CORBA::ORB::InvalidName);
    CORBA::TypeCode create_alias_tc(in CORBA::RepositoryId id, in CORBA::Identifier name, in CORBA::TypeCode original_type);
    CORBA::TypeCode create_interface_tc(in CORBA::RepositoryId id, in CORBA::Identifier name);
    CORBA::TypeCode create_string_tc(in unsigned long bound);
    CORBA::TypeCode create_wstring_tc(in unsigned long bound);
    CORBA::TypeCode create_fixed_tc(in unsigned short digits, in short scale);
    CORBA::TypeCode create_sequence_tc(in unsigned long bound, in CORBA::TypeCode element_type);
    CORBA::TypeCode create_recursive_sequence_tc(in unsigned long bound, in unsigned long offset);
    CORBA::TypeCode create_array_tc(in unsigned long length, in CORBA::TypeCode element_type);
    CORBA::TypeCode create_native_tc(in CORBA::RepositoryId id, in CORBA::Identifier name);
    boolean work_pending();
    void perform_work();
    void run();
    void shutdown(in boolean wait_for_completion);
    CORBA::Policy create_policy(in CORBA::PolicyType type, in any val) raises (CORBA::PolicyError);
    void register_initial_reference(in CORBA::ORB::ObjectId id, in CORBA::OObject obj) raises (CORBA::ORB::InvalidName);
  };
  interface Request {
    void invoke(in CORBA::Flags invoke_flags);
    void delete();
  };
  interface CContext {
    void set_one_value(in CORBA::Identifier prop_name, in string value);
    void set_values(in CORBA::NVList values);
    void get_values(in CORBA::Identifier start_scope, in CORBA::Flags op_flags, in CORBA::Identifier prop_name, out CORBA::NVList values);
    void delete_values(in CORBA::Identifier prop_name);
    void create_child(in CORBA::Identifier ctx_name, out CORBA::CContext child_ctx);
    void delete(in CORBA::Flags del_flags);
  };
  interface NVList {
    void free();
    void free_memory();
    void get_count(out long count);
  };
  interface ServerRequest {
    readonly attribute CORBA::Identifier operation;
    void arguments(inout CORBA::NVList nv);
    CORBA::CContext ctx();
    void set_result(in any val);
    void set_exception(in any val);
  };
};
enum EggPlant {
  Banana,
  Carrots,
  Lemon,
  BlackCherry,
  Starfruit,
  Rhubarb
};
typedef struct Zucchini {
  short Pumpkin;
} Avocado;
union Lentil switch (long) {
    case 23 :
    octet Lime;
    case -25 :
    Avocado Coconut;
    default :
    short Lychees;
};
interface siiServer {
  attribute float Cucumber;
  attribute double Ginger;
  attribute long Apricots;
  attribute unsigned long BlackEyedBeans;
  attribute short Leek;
  attribute unsigned short Mint;
  attribute char GardenPeas;
  attribute boolean Fig;
  attribute octet Asparagus;
  attribute string GaliaMelon;
  attribute CORBA::OObject Turnip;
  attribute any Orange;
  attribute CORBA::TypeCode LoganBerry;
  readonly attribute float Parsnip;
  readonly attribute double Celery;
  readonly attribute long WhiteCabbage;
  readonly attribute unsigned long Aniseed;
  readonly attribute short Bayleaf;
  readonly attribute unsigned short Dill;
  readonly attribute char Oregano;
  readonly attribute boolean Beansprout;
  readonly attribute octet Almonds;
  readonly attribute string Guava;
  readonly attribute CORBA::OObject Runnerbean;
  readonly attribute any Tofu;
  readonly attribute CORBA::TypeCode Prunes;
  attribute EggPlant GrannySmith;
  attribute Zucchini Billberries;
  attribute Avocado LolloRossa;
  attribute Lentil Sweetcorn;
  readonly attribute EggPlant Shallots;
  readonly attribute Zucchini ButterBean;
  readonly attribute Avocado GoldenDelicous;
  readonly attribute Lentil CrabApple;
  attribute long RedOnion, HazelNut, Cinnamon, GooseBerry;
  attribute EggPlant JuniperBerries, Cloves, Daikan, Mustard;
};
